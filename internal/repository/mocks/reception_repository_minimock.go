// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i PVZ/internal/repository.ReceptionRepository -o reception_repository_minimock.go -n ReceptionRepositoryMock -p mocks

import (
	"PVZ/internal/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ReceptionRepositoryMock implements mm_repository.ReceptionRepository
type ReceptionRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddProduct          func(ctx context.Context, product *model.Product) (err error)
	funcAddProductOrigin    string
	inspectFuncAddProduct   func(ctx context.Context, product *model.Product)
	afterAddProductCounter  uint64
	beforeAddProductCounter uint64
	AddProductMock          mReceptionRepositoryMockAddProduct

	funcCloseReception          func(ctx context.Context, receptionID string) (err error)
	funcCloseReceptionOrigin    string
	inspectFuncCloseReception   func(ctx context.Context, receptionID string)
	afterCloseReceptionCounter  uint64
	beforeCloseReceptionCounter uint64
	CloseReceptionMock          mReceptionRepositoryMockCloseReception

	funcCreate          func(ctx context.Context, reception *model.Reception) (rp1 *model.Reception, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, reception *model.Reception)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mReceptionRepositoryMockCreate

	funcDeleteLastProductByPVZ          func(ctx context.Context, pvzID string) (err error)
	funcDeleteLastProductByPVZOrigin    string
	inspectFuncDeleteLastProductByPVZ   func(ctx context.Context, pvzID string)
	afterDeleteLastProductByPVZCounter  uint64
	beforeDeleteLastProductByPVZCounter uint64
	DeleteLastProductByPVZMock          mReceptionRepositoryMockDeleteLastProductByPVZ

	funcGetOpenReceptionForPVZ          func(ctx context.Context, pvzID string) (rp1 *model.Reception, err error)
	funcGetOpenReceptionForPVZOrigin    string
	inspectFuncGetOpenReceptionForPVZ   func(ctx context.Context, pvzID string)
	afterGetOpenReceptionForPVZCounter  uint64
	beforeGetOpenReceptionForPVZCounter uint64
	GetOpenReceptionForPVZMock          mReceptionRepositoryMockGetOpenReceptionForPVZ

	funcGetProductsByReception          func(ctx context.Context, receptionID string) (ppa1 []*model.Product, err error)
	funcGetProductsByReceptionOrigin    string
	inspectFuncGetProductsByReception   func(ctx context.Context, receptionID string)
	afterGetProductsByReceptionCounter  uint64
	beforeGetProductsByReceptionCounter uint64
	GetProductsByReceptionMock          mReceptionRepositoryMockGetProductsByReception

	funcGetReceptionsByPVZ          func(ctx context.Context, pvzID string, startDate *string, endDate *string) (rpa1 []*model.Reception, err error)
	funcGetReceptionsByPVZOrigin    string
	inspectFuncGetReceptionsByPVZ   func(ctx context.Context, pvzID string, startDate *string, endDate *string)
	afterGetReceptionsByPVZCounter  uint64
	beforeGetReceptionsByPVZCounter uint64
	GetReceptionsByPVZMock          mReceptionRepositoryMockGetReceptionsByPVZ
}

// NewReceptionRepositoryMock returns a mock for mm_repository.ReceptionRepository
func NewReceptionRepositoryMock(t minimock.Tester) *ReceptionRepositoryMock {
	m := &ReceptionRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddProductMock = mReceptionRepositoryMockAddProduct{mock: m}
	m.AddProductMock.callArgs = []*ReceptionRepositoryMockAddProductParams{}

	m.CloseReceptionMock = mReceptionRepositoryMockCloseReception{mock: m}
	m.CloseReceptionMock.callArgs = []*ReceptionRepositoryMockCloseReceptionParams{}

	m.CreateMock = mReceptionRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*ReceptionRepositoryMockCreateParams{}

	m.DeleteLastProductByPVZMock = mReceptionRepositoryMockDeleteLastProductByPVZ{mock: m}
	m.DeleteLastProductByPVZMock.callArgs = []*ReceptionRepositoryMockDeleteLastProductByPVZParams{}

	m.GetOpenReceptionForPVZMock = mReceptionRepositoryMockGetOpenReceptionForPVZ{mock: m}
	m.GetOpenReceptionForPVZMock.callArgs = []*ReceptionRepositoryMockGetOpenReceptionForPVZParams{}

	m.GetProductsByReceptionMock = mReceptionRepositoryMockGetProductsByReception{mock: m}
	m.GetProductsByReceptionMock.callArgs = []*ReceptionRepositoryMockGetProductsByReceptionParams{}

	m.GetReceptionsByPVZMock = mReceptionRepositoryMockGetReceptionsByPVZ{mock: m}
	m.GetReceptionsByPVZMock.callArgs = []*ReceptionRepositoryMockGetReceptionsByPVZParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mReceptionRepositoryMockAddProduct struct {
	optional           bool
	mock               *ReceptionRepositoryMock
	defaultExpectation *ReceptionRepositoryMockAddProductExpectation
	expectations       []*ReceptionRepositoryMockAddProductExpectation

	callArgs []*ReceptionRepositoryMockAddProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionRepositoryMockAddProductExpectation specifies expectation struct of the ReceptionRepository.AddProduct
type ReceptionRepositoryMockAddProductExpectation struct {
	mock               *ReceptionRepositoryMock
	params             *ReceptionRepositoryMockAddProductParams
	paramPtrs          *ReceptionRepositoryMockAddProductParamPtrs
	expectationOrigins ReceptionRepositoryMockAddProductExpectationOrigins
	results            *ReceptionRepositoryMockAddProductResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionRepositoryMockAddProductParams contains parameters of the ReceptionRepository.AddProduct
type ReceptionRepositoryMockAddProductParams struct {
	ctx     context.Context
	product *model.Product
}

// ReceptionRepositoryMockAddProductParamPtrs contains pointers to parameters of the ReceptionRepository.AddProduct
type ReceptionRepositoryMockAddProductParamPtrs struct {
	ctx     *context.Context
	product **model.Product
}

// ReceptionRepositoryMockAddProductResults contains results of the ReceptionRepository.AddProduct
type ReceptionRepositoryMockAddProductResults struct {
	err error
}

// ReceptionRepositoryMockAddProductOrigins contains origins of expectations of the ReceptionRepository.AddProduct
type ReceptionRepositoryMockAddProductExpectationOrigins struct {
	origin        string
	originCtx     string
	originProduct string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddProduct *mReceptionRepositoryMockAddProduct) Optional() *mReceptionRepositoryMockAddProduct {
	mmAddProduct.optional = true
	return mmAddProduct
}

// Expect sets up expected params for ReceptionRepository.AddProduct
func (mmAddProduct *mReceptionRepositoryMockAddProduct) Expect(ctx context.Context, product *model.Product) *mReceptionRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &ReceptionRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.paramPtrs != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionRepositoryMock.AddProduct mock is already set by ExpectParams functions")
	}

	mmAddProduct.defaultExpectation.params = &ReceptionRepositoryMockAddProductParams{ctx, product}
	mmAddProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddProduct.expectations {
		if minimock.Equal(e.params, mmAddProduct.defaultExpectation.params) {
			mmAddProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddProduct.defaultExpectation.params)
		}
	}

	return mmAddProduct
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionRepository.AddProduct
func (mmAddProduct *mReceptionRepositoryMockAddProduct) ExpectCtxParam1(ctx context.Context) *mReceptionRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &ReceptionRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionRepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &ReceptionRepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddProduct
}

// ExpectProductParam2 sets up expected param product for ReceptionRepository.AddProduct
func (mmAddProduct *mReceptionRepositoryMockAddProduct) ExpectProductParam2(product *model.Product) *mReceptionRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &ReceptionRepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionRepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &ReceptionRepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.product = &product
	mmAddProduct.defaultExpectation.expectationOrigins.originProduct = minimock.CallerInfo(1)

	return mmAddProduct
}

// Inspect accepts an inspector function that has same arguments as the ReceptionRepository.AddProduct
func (mmAddProduct *mReceptionRepositoryMockAddProduct) Inspect(f func(ctx context.Context, product *model.Product)) *mReceptionRepositoryMockAddProduct {
	if mmAddProduct.mock.inspectFuncAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("Inspect function is already set for ReceptionRepositoryMock.AddProduct")
	}

	mmAddProduct.mock.inspectFuncAddProduct = f

	return mmAddProduct
}

// Return sets up results that will be returned by ReceptionRepository.AddProduct
func (mmAddProduct *mReceptionRepositoryMockAddProduct) Return(err error) *ReceptionRepositoryMock {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionRepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &ReceptionRepositoryMockAddProductExpectation{mock: mmAddProduct.mock}
	}
	mmAddProduct.defaultExpectation.results = &ReceptionRepositoryMockAddProductResults{err}
	mmAddProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddProduct.mock
}

// Set uses given function f to mock the ReceptionRepository.AddProduct method
func (mmAddProduct *mReceptionRepositoryMockAddProduct) Set(f func(ctx context.Context, product *model.Product) (err error)) *ReceptionRepositoryMock {
	if mmAddProduct.defaultExpectation != nil {
		mmAddProduct.mock.t.Fatalf("Default expectation is already set for the ReceptionRepository.AddProduct method")
	}

	if len(mmAddProduct.expectations) > 0 {
		mmAddProduct.mock.t.Fatalf("Some expectations are already set for the ReceptionRepository.AddProduct method")
	}

	mmAddProduct.mock.funcAddProduct = f
	mmAddProduct.mock.funcAddProductOrigin = minimock.CallerInfo(1)
	return mmAddProduct.mock
}

// When sets expectation for the ReceptionRepository.AddProduct which will trigger the result defined by the following
// Then helper
func (mmAddProduct *mReceptionRepositoryMockAddProduct) When(ctx context.Context, product *model.Product) *ReceptionRepositoryMockAddProductExpectation {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionRepositoryMock.AddProduct mock is already set by Set")
	}

	expectation := &ReceptionRepositoryMockAddProductExpectation{
		mock:               mmAddProduct.mock,
		params:             &ReceptionRepositoryMockAddProductParams{ctx, product},
		expectationOrigins: ReceptionRepositoryMockAddProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddProduct.expectations = append(mmAddProduct.expectations, expectation)
	return expectation
}

// Then sets up ReceptionRepository.AddProduct return parameters for the expectation previously defined by the When method
func (e *ReceptionRepositoryMockAddProductExpectation) Then(err error) *ReceptionRepositoryMock {
	e.results = &ReceptionRepositoryMockAddProductResults{err}
	return e.mock
}

// Times sets number of times ReceptionRepository.AddProduct should be invoked
func (mmAddProduct *mReceptionRepositoryMockAddProduct) Times(n uint64) *mReceptionRepositoryMockAddProduct {
	if n == 0 {
		mmAddProduct.mock.t.Fatalf("Times of ReceptionRepositoryMock.AddProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddProduct.expectedInvocations, n)
	mmAddProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddProduct
}

func (mmAddProduct *mReceptionRepositoryMockAddProduct) invocationsDone() bool {
	if len(mmAddProduct.expectations) == 0 && mmAddProduct.defaultExpectation == nil && mmAddProduct.mock.funcAddProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddProduct.mock.afterAddProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddProduct implements mm_repository.ReceptionRepository
func (mmAddProduct *ReceptionRepositoryMock) AddProduct(ctx context.Context, product *model.Product) (err error) {
	mm_atomic.AddUint64(&mmAddProduct.beforeAddProductCounter, 1)
	defer mm_atomic.AddUint64(&mmAddProduct.afterAddProductCounter, 1)

	mmAddProduct.t.Helper()

	if mmAddProduct.inspectFuncAddProduct != nil {
		mmAddProduct.inspectFuncAddProduct(ctx, product)
	}

	mm_params := ReceptionRepositoryMockAddProductParams{ctx, product}

	// Record call args
	mmAddProduct.AddProductMock.mutex.Lock()
	mmAddProduct.AddProductMock.callArgs = append(mmAddProduct.AddProductMock.callArgs, &mm_params)
	mmAddProduct.AddProductMock.mutex.Unlock()

	for _, e := range mmAddProduct.AddProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddProduct.AddProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddProduct.AddProductMock.defaultExpectation.Counter, 1)
		mm_want := mmAddProduct.AddProductMock.defaultExpectation.params
		mm_want_ptrs := mmAddProduct.AddProductMock.defaultExpectation.paramPtrs

		mm_got := ReceptionRepositoryMockAddProductParams{ctx, product}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddProduct.t.Errorf("ReceptionRepositoryMock.AddProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.product != nil && !minimock.Equal(*mm_want_ptrs.product, mm_got.product) {
				mmAddProduct.t.Errorf("ReceptionRepositoryMock.AddProduct got unexpected parameter product, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originProduct, *mm_want_ptrs.product, mm_got.product, minimock.Diff(*mm_want_ptrs.product, mm_got.product))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddProduct.t.Errorf("ReceptionRepositoryMock.AddProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddProduct.AddProductMock.defaultExpectation.results
		if mm_results == nil {
			mmAddProduct.t.Fatal("No results are set for the ReceptionRepositoryMock.AddProduct")
		}
		return (*mm_results).err
	}
	if mmAddProduct.funcAddProduct != nil {
		return mmAddProduct.funcAddProduct(ctx, product)
	}
	mmAddProduct.t.Fatalf("Unexpected call to ReceptionRepositoryMock.AddProduct. %v %v", ctx, product)
	return
}

// AddProductAfterCounter returns a count of finished ReceptionRepositoryMock.AddProduct invocations
func (mmAddProduct *ReceptionRepositoryMock) AddProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.afterAddProductCounter)
}

// AddProductBeforeCounter returns a count of ReceptionRepositoryMock.AddProduct invocations
func (mmAddProduct *ReceptionRepositoryMock) AddProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.beforeAddProductCounter)
}

// Calls returns a list of arguments used in each call to ReceptionRepositoryMock.AddProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddProduct *mReceptionRepositoryMockAddProduct) Calls() []*ReceptionRepositoryMockAddProductParams {
	mmAddProduct.mutex.RLock()

	argCopy := make([]*ReceptionRepositoryMockAddProductParams, len(mmAddProduct.callArgs))
	copy(argCopy, mmAddProduct.callArgs)

	mmAddProduct.mutex.RUnlock()

	return argCopy
}

// MinimockAddProductDone returns true if the count of the AddProduct invocations corresponds
// the number of defined expectations
func (m *ReceptionRepositoryMock) MinimockAddProductDone() bool {
	if m.AddProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddProductMock.invocationsDone()
}

// MinimockAddProductInspect logs each unmet expectation
func (m *ReceptionRepositoryMock) MinimockAddProductInspect() {
	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.AddProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddProductCounter := mm_atomic.LoadUint64(&m.afterAddProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddProductMock.defaultExpectation != nil && afterAddProductCounter < 1 {
		if m.AddProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.AddProduct at\n%s", m.AddProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.AddProduct at\n%s with params: %#v", m.AddProductMock.defaultExpectation.expectationOrigins.origin, *m.AddProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddProduct != nil && afterAddProductCounter < 1 {
		m.t.Errorf("Expected call to ReceptionRepositoryMock.AddProduct at\n%s", m.funcAddProductOrigin)
	}

	if !m.AddProductMock.invocationsDone() && afterAddProductCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionRepositoryMock.AddProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddProductMock.expectedInvocations), m.AddProductMock.expectedInvocationsOrigin, afterAddProductCounter)
	}
}

type mReceptionRepositoryMockCloseReception struct {
	optional           bool
	mock               *ReceptionRepositoryMock
	defaultExpectation *ReceptionRepositoryMockCloseReceptionExpectation
	expectations       []*ReceptionRepositoryMockCloseReceptionExpectation

	callArgs []*ReceptionRepositoryMockCloseReceptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionRepositoryMockCloseReceptionExpectation specifies expectation struct of the ReceptionRepository.CloseReception
type ReceptionRepositoryMockCloseReceptionExpectation struct {
	mock               *ReceptionRepositoryMock
	params             *ReceptionRepositoryMockCloseReceptionParams
	paramPtrs          *ReceptionRepositoryMockCloseReceptionParamPtrs
	expectationOrigins ReceptionRepositoryMockCloseReceptionExpectationOrigins
	results            *ReceptionRepositoryMockCloseReceptionResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionRepositoryMockCloseReceptionParams contains parameters of the ReceptionRepository.CloseReception
type ReceptionRepositoryMockCloseReceptionParams struct {
	ctx         context.Context
	receptionID string
}

// ReceptionRepositoryMockCloseReceptionParamPtrs contains pointers to parameters of the ReceptionRepository.CloseReception
type ReceptionRepositoryMockCloseReceptionParamPtrs struct {
	ctx         *context.Context
	receptionID *string
}

// ReceptionRepositoryMockCloseReceptionResults contains results of the ReceptionRepository.CloseReception
type ReceptionRepositoryMockCloseReceptionResults struct {
	err error
}

// ReceptionRepositoryMockCloseReceptionOrigins contains origins of expectations of the ReceptionRepository.CloseReception
type ReceptionRepositoryMockCloseReceptionExpectationOrigins struct {
	origin            string
	originCtx         string
	originReceptionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCloseReception *mReceptionRepositoryMockCloseReception) Optional() *mReceptionRepositoryMockCloseReception {
	mmCloseReception.optional = true
	return mmCloseReception
}

// Expect sets up expected params for ReceptionRepository.CloseReception
func (mmCloseReception *mReceptionRepositoryMockCloseReception) Expect(ctx context.Context, receptionID string) *mReceptionRepositoryMockCloseReception {
	if mmCloseReception.mock.funcCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionRepositoryMock.CloseReception mock is already set by Set")
	}

	if mmCloseReception.defaultExpectation == nil {
		mmCloseReception.defaultExpectation = &ReceptionRepositoryMockCloseReceptionExpectation{}
	}

	if mmCloseReception.defaultExpectation.paramPtrs != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionRepositoryMock.CloseReception mock is already set by ExpectParams functions")
	}

	mmCloseReception.defaultExpectation.params = &ReceptionRepositoryMockCloseReceptionParams{ctx, receptionID}
	mmCloseReception.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCloseReception.expectations {
		if minimock.Equal(e.params, mmCloseReception.defaultExpectation.params) {
			mmCloseReception.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCloseReception.defaultExpectation.params)
		}
	}

	return mmCloseReception
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionRepository.CloseReception
func (mmCloseReception *mReceptionRepositoryMockCloseReception) ExpectCtxParam1(ctx context.Context) *mReceptionRepositoryMockCloseReception {
	if mmCloseReception.mock.funcCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionRepositoryMock.CloseReception mock is already set by Set")
	}

	if mmCloseReception.defaultExpectation == nil {
		mmCloseReception.defaultExpectation = &ReceptionRepositoryMockCloseReceptionExpectation{}
	}

	if mmCloseReception.defaultExpectation.params != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionRepositoryMock.CloseReception mock is already set by Expect")
	}

	if mmCloseReception.defaultExpectation.paramPtrs == nil {
		mmCloseReception.defaultExpectation.paramPtrs = &ReceptionRepositoryMockCloseReceptionParamPtrs{}
	}
	mmCloseReception.defaultExpectation.paramPtrs.ctx = &ctx
	mmCloseReception.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCloseReception
}

// ExpectReceptionIDParam2 sets up expected param receptionID for ReceptionRepository.CloseReception
func (mmCloseReception *mReceptionRepositoryMockCloseReception) ExpectReceptionIDParam2(receptionID string) *mReceptionRepositoryMockCloseReception {
	if mmCloseReception.mock.funcCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionRepositoryMock.CloseReception mock is already set by Set")
	}

	if mmCloseReception.defaultExpectation == nil {
		mmCloseReception.defaultExpectation = &ReceptionRepositoryMockCloseReceptionExpectation{}
	}

	if mmCloseReception.defaultExpectation.params != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionRepositoryMock.CloseReception mock is already set by Expect")
	}

	if mmCloseReception.defaultExpectation.paramPtrs == nil {
		mmCloseReception.defaultExpectation.paramPtrs = &ReceptionRepositoryMockCloseReceptionParamPtrs{}
	}
	mmCloseReception.defaultExpectation.paramPtrs.receptionID = &receptionID
	mmCloseReception.defaultExpectation.expectationOrigins.originReceptionID = minimock.CallerInfo(1)

	return mmCloseReception
}

// Inspect accepts an inspector function that has same arguments as the ReceptionRepository.CloseReception
func (mmCloseReception *mReceptionRepositoryMockCloseReception) Inspect(f func(ctx context.Context, receptionID string)) *mReceptionRepositoryMockCloseReception {
	if mmCloseReception.mock.inspectFuncCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("Inspect function is already set for ReceptionRepositoryMock.CloseReception")
	}

	mmCloseReception.mock.inspectFuncCloseReception = f

	return mmCloseReception
}

// Return sets up results that will be returned by ReceptionRepository.CloseReception
func (mmCloseReception *mReceptionRepositoryMockCloseReception) Return(err error) *ReceptionRepositoryMock {
	if mmCloseReception.mock.funcCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionRepositoryMock.CloseReception mock is already set by Set")
	}

	if mmCloseReception.defaultExpectation == nil {
		mmCloseReception.defaultExpectation = &ReceptionRepositoryMockCloseReceptionExpectation{mock: mmCloseReception.mock}
	}
	mmCloseReception.defaultExpectation.results = &ReceptionRepositoryMockCloseReceptionResults{err}
	mmCloseReception.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCloseReception.mock
}

// Set uses given function f to mock the ReceptionRepository.CloseReception method
func (mmCloseReception *mReceptionRepositoryMockCloseReception) Set(f func(ctx context.Context, receptionID string) (err error)) *ReceptionRepositoryMock {
	if mmCloseReception.defaultExpectation != nil {
		mmCloseReception.mock.t.Fatalf("Default expectation is already set for the ReceptionRepository.CloseReception method")
	}

	if len(mmCloseReception.expectations) > 0 {
		mmCloseReception.mock.t.Fatalf("Some expectations are already set for the ReceptionRepository.CloseReception method")
	}

	mmCloseReception.mock.funcCloseReception = f
	mmCloseReception.mock.funcCloseReceptionOrigin = minimock.CallerInfo(1)
	return mmCloseReception.mock
}

// When sets expectation for the ReceptionRepository.CloseReception which will trigger the result defined by the following
// Then helper
func (mmCloseReception *mReceptionRepositoryMockCloseReception) When(ctx context.Context, receptionID string) *ReceptionRepositoryMockCloseReceptionExpectation {
	if mmCloseReception.mock.funcCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionRepositoryMock.CloseReception mock is already set by Set")
	}

	expectation := &ReceptionRepositoryMockCloseReceptionExpectation{
		mock:               mmCloseReception.mock,
		params:             &ReceptionRepositoryMockCloseReceptionParams{ctx, receptionID},
		expectationOrigins: ReceptionRepositoryMockCloseReceptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCloseReception.expectations = append(mmCloseReception.expectations, expectation)
	return expectation
}

// Then sets up ReceptionRepository.CloseReception return parameters for the expectation previously defined by the When method
func (e *ReceptionRepositoryMockCloseReceptionExpectation) Then(err error) *ReceptionRepositoryMock {
	e.results = &ReceptionRepositoryMockCloseReceptionResults{err}
	return e.mock
}

// Times sets number of times ReceptionRepository.CloseReception should be invoked
func (mmCloseReception *mReceptionRepositoryMockCloseReception) Times(n uint64) *mReceptionRepositoryMockCloseReception {
	if n == 0 {
		mmCloseReception.mock.t.Fatalf("Times of ReceptionRepositoryMock.CloseReception mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCloseReception.expectedInvocations, n)
	mmCloseReception.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCloseReception
}

func (mmCloseReception *mReceptionRepositoryMockCloseReception) invocationsDone() bool {
	if len(mmCloseReception.expectations) == 0 && mmCloseReception.defaultExpectation == nil && mmCloseReception.mock.funcCloseReception == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCloseReception.mock.afterCloseReceptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCloseReception.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CloseReception implements mm_repository.ReceptionRepository
func (mmCloseReception *ReceptionRepositoryMock) CloseReception(ctx context.Context, receptionID string) (err error) {
	mm_atomic.AddUint64(&mmCloseReception.beforeCloseReceptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCloseReception.afterCloseReceptionCounter, 1)

	mmCloseReception.t.Helper()

	if mmCloseReception.inspectFuncCloseReception != nil {
		mmCloseReception.inspectFuncCloseReception(ctx, receptionID)
	}

	mm_params := ReceptionRepositoryMockCloseReceptionParams{ctx, receptionID}

	// Record call args
	mmCloseReception.CloseReceptionMock.mutex.Lock()
	mmCloseReception.CloseReceptionMock.callArgs = append(mmCloseReception.CloseReceptionMock.callArgs, &mm_params)
	mmCloseReception.CloseReceptionMock.mutex.Unlock()

	for _, e := range mmCloseReception.CloseReceptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCloseReception.CloseReceptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCloseReception.CloseReceptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCloseReception.CloseReceptionMock.defaultExpectation.params
		mm_want_ptrs := mmCloseReception.CloseReceptionMock.defaultExpectation.paramPtrs

		mm_got := ReceptionRepositoryMockCloseReceptionParams{ctx, receptionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCloseReception.t.Errorf("ReceptionRepositoryMock.CloseReception got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseReception.CloseReceptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.receptionID != nil && !minimock.Equal(*mm_want_ptrs.receptionID, mm_got.receptionID) {
				mmCloseReception.t.Errorf("ReceptionRepositoryMock.CloseReception got unexpected parameter receptionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseReception.CloseReceptionMock.defaultExpectation.expectationOrigins.originReceptionID, *mm_want_ptrs.receptionID, mm_got.receptionID, minimock.Diff(*mm_want_ptrs.receptionID, mm_got.receptionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCloseReception.t.Errorf("ReceptionRepositoryMock.CloseReception got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCloseReception.CloseReceptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCloseReception.CloseReceptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCloseReception.t.Fatal("No results are set for the ReceptionRepositoryMock.CloseReception")
		}
		return (*mm_results).err
	}
	if mmCloseReception.funcCloseReception != nil {
		return mmCloseReception.funcCloseReception(ctx, receptionID)
	}
	mmCloseReception.t.Fatalf("Unexpected call to ReceptionRepositoryMock.CloseReception. %v %v", ctx, receptionID)
	return
}

// CloseReceptionAfterCounter returns a count of finished ReceptionRepositoryMock.CloseReception invocations
func (mmCloseReception *ReceptionRepositoryMock) CloseReceptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseReception.afterCloseReceptionCounter)
}

// CloseReceptionBeforeCounter returns a count of ReceptionRepositoryMock.CloseReception invocations
func (mmCloseReception *ReceptionRepositoryMock) CloseReceptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseReception.beforeCloseReceptionCounter)
}

// Calls returns a list of arguments used in each call to ReceptionRepositoryMock.CloseReception.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCloseReception *mReceptionRepositoryMockCloseReception) Calls() []*ReceptionRepositoryMockCloseReceptionParams {
	mmCloseReception.mutex.RLock()

	argCopy := make([]*ReceptionRepositoryMockCloseReceptionParams, len(mmCloseReception.callArgs))
	copy(argCopy, mmCloseReception.callArgs)

	mmCloseReception.mutex.RUnlock()

	return argCopy
}

// MinimockCloseReceptionDone returns true if the count of the CloseReception invocations corresponds
// the number of defined expectations
func (m *ReceptionRepositoryMock) MinimockCloseReceptionDone() bool {
	if m.CloseReceptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseReceptionMock.invocationsDone()
}

// MinimockCloseReceptionInspect logs each unmet expectation
func (m *ReceptionRepositoryMock) MinimockCloseReceptionInspect() {
	for _, e := range m.CloseReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.CloseReception at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCloseReceptionCounter := mm_atomic.LoadUint64(&m.afterCloseReceptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseReceptionMock.defaultExpectation != nil && afterCloseReceptionCounter < 1 {
		if m.CloseReceptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.CloseReception at\n%s", m.CloseReceptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.CloseReception at\n%s with params: %#v", m.CloseReceptionMock.defaultExpectation.expectationOrigins.origin, *m.CloseReceptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseReception != nil && afterCloseReceptionCounter < 1 {
		m.t.Errorf("Expected call to ReceptionRepositoryMock.CloseReception at\n%s", m.funcCloseReceptionOrigin)
	}

	if !m.CloseReceptionMock.invocationsDone() && afterCloseReceptionCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionRepositoryMock.CloseReception at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseReceptionMock.expectedInvocations), m.CloseReceptionMock.expectedInvocationsOrigin, afterCloseReceptionCounter)
	}
}

type mReceptionRepositoryMockCreate struct {
	optional           bool
	mock               *ReceptionRepositoryMock
	defaultExpectation *ReceptionRepositoryMockCreateExpectation
	expectations       []*ReceptionRepositoryMockCreateExpectation

	callArgs []*ReceptionRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionRepositoryMockCreateExpectation specifies expectation struct of the ReceptionRepository.Create
type ReceptionRepositoryMockCreateExpectation struct {
	mock               *ReceptionRepositoryMock
	params             *ReceptionRepositoryMockCreateParams
	paramPtrs          *ReceptionRepositoryMockCreateParamPtrs
	expectationOrigins ReceptionRepositoryMockCreateExpectationOrigins
	results            *ReceptionRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionRepositoryMockCreateParams contains parameters of the ReceptionRepository.Create
type ReceptionRepositoryMockCreateParams struct {
	ctx       context.Context
	reception *model.Reception
}

// ReceptionRepositoryMockCreateParamPtrs contains pointers to parameters of the ReceptionRepository.Create
type ReceptionRepositoryMockCreateParamPtrs struct {
	ctx       *context.Context
	reception **model.Reception
}

// ReceptionRepositoryMockCreateResults contains results of the ReceptionRepository.Create
type ReceptionRepositoryMockCreateResults struct {
	rp1 *model.Reception
	err error
}

// ReceptionRepositoryMockCreateOrigins contains origins of expectations of the ReceptionRepository.Create
type ReceptionRepositoryMockCreateExpectationOrigins struct {
	origin          string
	originCtx       string
	originReception string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mReceptionRepositoryMockCreate) Optional() *mReceptionRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for ReceptionRepository.Create
func (mmCreate *mReceptionRepositoryMockCreate) Expect(ctx context.Context, reception *model.Reception) *mReceptionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ReceptionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ReceptionRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ReceptionRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ReceptionRepositoryMockCreateParams{ctx, reception}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionRepository.Create
func (mmCreate *mReceptionRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mReceptionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ReceptionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ReceptionRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ReceptionRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ReceptionRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectReceptionParam2 sets up expected param reception for ReceptionRepository.Create
func (mmCreate *mReceptionRepositoryMockCreate) ExpectReceptionParam2(reception *model.Reception) *mReceptionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ReceptionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ReceptionRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ReceptionRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ReceptionRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.reception = &reception
	mmCreate.defaultExpectation.expectationOrigins.originReception = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ReceptionRepository.Create
func (mmCreate *mReceptionRepositoryMockCreate) Inspect(f func(ctx context.Context, reception *model.Reception)) *mReceptionRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ReceptionRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ReceptionRepository.Create
func (mmCreate *mReceptionRepositoryMockCreate) Return(rp1 *model.Reception, err error) *ReceptionRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ReceptionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ReceptionRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ReceptionRepositoryMockCreateResults{rp1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the ReceptionRepository.Create method
func (mmCreate *mReceptionRepositoryMockCreate) Set(f func(ctx context.Context, reception *model.Reception) (rp1 *model.Reception, err error)) *ReceptionRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ReceptionRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ReceptionRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the ReceptionRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mReceptionRepositoryMockCreate) When(ctx context.Context, reception *model.Reception) *ReceptionRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ReceptionRepositoryMock.Create mock is already set by Set")
	}

	expectation := &ReceptionRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &ReceptionRepositoryMockCreateParams{ctx, reception},
		expectationOrigins: ReceptionRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ReceptionRepository.Create return parameters for the expectation previously defined by the When method
func (e *ReceptionRepositoryMockCreateExpectation) Then(rp1 *model.Reception, err error) *ReceptionRepositoryMock {
	e.results = &ReceptionRepositoryMockCreateResults{rp1, err}
	return e.mock
}

// Times sets number of times ReceptionRepository.Create should be invoked
func (mmCreate *mReceptionRepositoryMockCreate) Times(n uint64) *mReceptionRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ReceptionRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mReceptionRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.ReceptionRepository
func (mmCreate *ReceptionRepositoryMock) Create(ctx context.Context, reception *model.Reception) (rp1 *model.Reception, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, reception)
	}

	mm_params := ReceptionRepositoryMockCreateParams{ctx, reception}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ReceptionRepositoryMockCreateParams{ctx, reception}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ReceptionRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.reception != nil && !minimock.Equal(*mm_want_ptrs.reception, mm_got.reception) {
				mmCreate.t.Errorf("ReceptionRepositoryMock.Create got unexpected parameter reception, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originReception, *mm_want_ptrs.reception, mm_got.reception, minimock.Diff(*mm_want_ptrs.reception, mm_got.reception))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ReceptionRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ReceptionRepositoryMock.Create")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, reception)
	}
	mmCreate.t.Fatalf("Unexpected call to ReceptionRepositoryMock.Create. %v %v", ctx, reception)
	return
}

// CreateAfterCounter returns a count of finished ReceptionRepositoryMock.Create invocations
func (mmCreate *ReceptionRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ReceptionRepositoryMock.Create invocations
func (mmCreate *ReceptionRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ReceptionRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mReceptionRepositoryMockCreate) Calls() []*ReceptionRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ReceptionRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ReceptionRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ReceptionRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to ReceptionRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mReceptionRepositoryMockDeleteLastProductByPVZ struct {
	optional           bool
	mock               *ReceptionRepositoryMock
	defaultExpectation *ReceptionRepositoryMockDeleteLastProductByPVZExpectation
	expectations       []*ReceptionRepositoryMockDeleteLastProductByPVZExpectation

	callArgs []*ReceptionRepositoryMockDeleteLastProductByPVZParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionRepositoryMockDeleteLastProductByPVZExpectation specifies expectation struct of the ReceptionRepository.DeleteLastProductByPVZ
type ReceptionRepositoryMockDeleteLastProductByPVZExpectation struct {
	mock               *ReceptionRepositoryMock
	params             *ReceptionRepositoryMockDeleteLastProductByPVZParams
	paramPtrs          *ReceptionRepositoryMockDeleteLastProductByPVZParamPtrs
	expectationOrigins ReceptionRepositoryMockDeleteLastProductByPVZExpectationOrigins
	results            *ReceptionRepositoryMockDeleteLastProductByPVZResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionRepositoryMockDeleteLastProductByPVZParams contains parameters of the ReceptionRepository.DeleteLastProductByPVZ
type ReceptionRepositoryMockDeleteLastProductByPVZParams struct {
	ctx   context.Context
	pvzID string
}

// ReceptionRepositoryMockDeleteLastProductByPVZParamPtrs contains pointers to parameters of the ReceptionRepository.DeleteLastProductByPVZ
type ReceptionRepositoryMockDeleteLastProductByPVZParamPtrs struct {
	ctx   *context.Context
	pvzID *string
}

// ReceptionRepositoryMockDeleteLastProductByPVZResults contains results of the ReceptionRepository.DeleteLastProductByPVZ
type ReceptionRepositoryMockDeleteLastProductByPVZResults struct {
	err error
}

// ReceptionRepositoryMockDeleteLastProductByPVZOrigins contains origins of expectations of the ReceptionRepository.DeleteLastProductByPVZ
type ReceptionRepositoryMockDeleteLastProductByPVZExpectationOrigins struct {
	origin      string
	originCtx   string
	originPvzID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) Optional() *mReceptionRepositoryMockDeleteLastProductByPVZ {
	mmDeleteLastProductByPVZ.optional = true
	return mmDeleteLastProductByPVZ
}

// Expect sets up expected params for ReceptionRepository.DeleteLastProductByPVZ
func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) Expect(ctx context.Context, pvzID string) *mReceptionRepositoryMockDeleteLastProductByPVZ {
	if mmDeleteLastProductByPVZ.mock.funcDeleteLastProductByPVZ != nil {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.DeleteLastProductByPVZ mock is already set by Set")
	}

	if mmDeleteLastProductByPVZ.defaultExpectation == nil {
		mmDeleteLastProductByPVZ.defaultExpectation = &ReceptionRepositoryMockDeleteLastProductByPVZExpectation{}
	}

	if mmDeleteLastProductByPVZ.defaultExpectation.paramPtrs != nil {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.DeleteLastProductByPVZ mock is already set by ExpectParams functions")
	}

	mmDeleteLastProductByPVZ.defaultExpectation.params = &ReceptionRepositoryMockDeleteLastProductByPVZParams{ctx, pvzID}
	mmDeleteLastProductByPVZ.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteLastProductByPVZ.expectations {
		if minimock.Equal(e.params, mmDeleteLastProductByPVZ.defaultExpectation.params) {
			mmDeleteLastProductByPVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteLastProductByPVZ.defaultExpectation.params)
		}
	}

	return mmDeleteLastProductByPVZ
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionRepository.DeleteLastProductByPVZ
func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) ExpectCtxParam1(ctx context.Context) *mReceptionRepositoryMockDeleteLastProductByPVZ {
	if mmDeleteLastProductByPVZ.mock.funcDeleteLastProductByPVZ != nil {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.DeleteLastProductByPVZ mock is already set by Set")
	}

	if mmDeleteLastProductByPVZ.defaultExpectation == nil {
		mmDeleteLastProductByPVZ.defaultExpectation = &ReceptionRepositoryMockDeleteLastProductByPVZExpectation{}
	}

	if mmDeleteLastProductByPVZ.defaultExpectation.params != nil {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.DeleteLastProductByPVZ mock is already set by Expect")
	}

	if mmDeleteLastProductByPVZ.defaultExpectation.paramPtrs == nil {
		mmDeleteLastProductByPVZ.defaultExpectation.paramPtrs = &ReceptionRepositoryMockDeleteLastProductByPVZParamPtrs{}
	}
	mmDeleteLastProductByPVZ.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteLastProductByPVZ.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteLastProductByPVZ
}

// ExpectPvzIDParam2 sets up expected param pvzID for ReceptionRepository.DeleteLastProductByPVZ
func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) ExpectPvzIDParam2(pvzID string) *mReceptionRepositoryMockDeleteLastProductByPVZ {
	if mmDeleteLastProductByPVZ.mock.funcDeleteLastProductByPVZ != nil {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.DeleteLastProductByPVZ mock is already set by Set")
	}

	if mmDeleteLastProductByPVZ.defaultExpectation == nil {
		mmDeleteLastProductByPVZ.defaultExpectation = &ReceptionRepositoryMockDeleteLastProductByPVZExpectation{}
	}

	if mmDeleteLastProductByPVZ.defaultExpectation.params != nil {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.DeleteLastProductByPVZ mock is already set by Expect")
	}

	if mmDeleteLastProductByPVZ.defaultExpectation.paramPtrs == nil {
		mmDeleteLastProductByPVZ.defaultExpectation.paramPtrs = &ReceptionRepositoryMockDeleteLastProductByPVZParamPtrs{}
	}
	mmDeleteLastProductByPVZ.defaultExpectation.paramPtrs.pvzID = &pvzID
	mmDeleteLastProductByPVZ.defaultExpectation.expectationOrigins.originPvzID = minimock.CallerInfo(1)

	return mmDeleteLastProductByPVZ
}

// Inspect accepts an inspector function that has same arguments as the ReceptionRepository.DeleteLastProductByPVZ
func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) Inspect(f func(ctx context.Context, pvzID string)) *mReceptionRepositoryMockDeleteLastProductByPVZ {
	if mmDeleteLastProductByPVZ.mock.inspectFuncDeleteLastProductByPVZ != nil {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("Inspect function is already set for ReceptionRepositoryMock.DeleteLastProductByPVZ")
	}

	mmDeleteLastProductByPVZ.mock.inspectFuncDeleteLastProductByPVZ = f

	return mmDeleteLastProductByPVZ
}

// Return sets up results that will be returned by ReceptionRepository.DeleteLastProductByPVZ
func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) Return(err error) *ReceptionRepositoryMock {
	if mmDeleteLastProductByPVZ.mock.funcDeleteLastProductByPVZ != nil {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.DeleteLastProductByPVZ mock is already set by Set")
	}

	if mmDeleteLastProductByPVZ.defaultExpectation == nil {
		mmDeleteLastProductByPVZ.defaultExpectation = &ReceptionRepositoryMockDeleteLastProductByPVZExpectation{mock: mmDeleteLastProductByPVZ.mock}
	}
	mmDeleteLastProductByPVZ.defaultExpectation.results = &ReceptionRepositoryMockDeleteLastProductByPVZResults{err}
	mmDeleteLastProductByPVZ.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteLastProductByPVZ.mock
}

// Set uses given function f to mock the ReceptionRepository.DeleteLastProductByPVZ method
func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) Set(f func(ctx context.Context, pvzID string) (err error)) *ReceptionRepositoryMock {
	if mmDeleteLastProductByPVZ.defaultExpectation != nil {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("Default expectation is already set for the ReceptionRepository.DeleteLastProductByPVZ method")
	}

	if len(mmDeleteLastProductByPVZ.expectations) > 0 {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("Some expectations are already set for the ReceptionRepository.DeleteLastProductByPVZ method")
	}

	mmDeleteLastProductByPVZ.mock.funcDeleteLastProductByPVZ = f
	mmDeleteLastProductByPVZ.mock.funcDeleteLastProductByPVZOrigin = minimock.CallerInfo(1)
	return mmDeleteLastProductByPVZ.mock
}

// When sets expectation for the ReceptionRepository.DeleteLastProductByPVZ which will trigger the result defined by the following
// Then helper
func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) When(ctx context.Context, pvzID string) *ReceptionRepositoryMockDeleteLastProductByPVZExpectation {
	if mmDeleteLastProductByPVZ.mock.funcDeleteLastProductByPVZ != nil {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.DeleteLastProductByPVZ mock is already set by Set")
	}

	expectation := &ReceptionRepositoryMockDeleteLastProductByPVZExpectation{
		mock:               mmDeleteLastProductByPVZ.mock,
		params:             &ReceptionRepositoryMockDeleteLastProductByPVZParams{ctx, pvzID},
		expectationOrigins: ReceptionRepositoryMockDeleteLastProductByPVZExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteLastProductByPVZ.expectations = append(mmDeleteLastProductByPVZ.expectations, expectation)
	return expectation
}

// Then sets up ReceptionRepository.DeleteLastProductByPVZ return parameters for the expectation previously defined by the When method
func (e *ReceptionRepositoryMockDeleteLastProductByPVZExpectation) Then(err error) *ReceptionRepositoryMock {
	e.results = &ReceptionRepositoryMockDeleteLastProductByPVZResults{err}
	return e.mock
}

// Times sets number of times ReceptionRepository.DeleteLastProductByPVZ should be invoked
func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) Times(n uint64) *mReceptionRepositoryMockDeleteLastProductByPVZ {
	if n == 0 {
		mmDeleteLastProductByPVZ.mock.t.Fatalf("Times of ReceptionRepositoryMock.DeleteLastProductByPVZ mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteLastProductByPVZ.expectedInvocations, n)
	mmDeleteLastProductByPVZ.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteLastProductByPVZ
}

func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) invocationsDone() bool {
	if len(mmDeleteLastProductByPVZ.expectations) == 0 && mmDeleteLastProductByPVZ.defaultExpectation == nil && mmDeleteLastProductByPVZ.mock.funcDeleteLastProductByPVZ == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteLastProductByPVZ.mock.afterDeleteLastProductByPVZCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteLastProductByPVZ.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteLastProductByPVZ implements mm_repository.ReceptionRepository
func (mmDeleteLastProductByPVZ *ReceptionRepositoryMock) DeleteLastProductByPVZ(ctx context.Context, pvzID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteLastProductByPVZ.beforeDeleteLastProductByPVZCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteLastProductByPVZ.afterDeleteLastProductByPVZCounter, 1)

	mmDeleteLastProductByPVZ.t.Helper()

	if mmDeleteLastProductByPVZ.inspectFuncDeleteLastProductByPVZ != nil {
		mmDeleteLastProductByPVZ.inspectFuncDeleteLastProductByPVZ(ctx, pvzID)
	}

	mm_params := ReceptionRepositoryMockDeleteLastProductByPVZParams{ctx, pvzID}

	// Record call args
	mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.mutex.Lock()
	mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.callArgs = append(mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.callArgs, &mm_params)
	mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.mutex.Unlock()

	for _, e := range mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.defaultExpectation.paramPtrs

		mm_got := ReceptionRepositoryMockDeleteLastProductByPVZParams{ctx, pvzID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteLastProductByPVZ.t.Errorf("ReceptionRepositoryMock.DeleteLastProductByPVZ got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzID != nil && !minimock.Equal(*mm_want_ptrs.pvzID, mm_got.pvzID) {
				mmDeleteLastProductByPVZ.t.Errorf("ReceptionRepositoryMock.DeleteLastProductByPVZ got unexpected parameter pvzID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.defaultExpectation.expectationOrigins.originPvzID, *mm_want_ptrs.pvzID, mm_got.pvzID, minimock.Diff(*mm_want_ptrs.pvzID, mm_got.pvzID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteLastProductByPVZ.t.Errorf("ReceptionRepositoryMock.DeleteLastProductByPVZ got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteLastProductByPVZ.DeleteLastProductByPVZMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteLastProductByPVZ.t.Fatal("No results are set for the ReceptionRepositoryMock.DeleteLastProductByPVZ")
		}
		return (*mm_results).err
	}
	if mmDeleteLastProductByPVZ.funcDeleteLastProductByPVZ != nil {
		return mmDeleteLastProductByPVZ.funcDeleteLastProductByPVZ(ctx, pvzID)
	}
	mmDeleteLastProductByPVZ.t.Fatalf("Unexpected call to ReceptionRepositoryMock.DeleteLastProductByPVZ. %v %v", ctx, pvzID)
	return
}

// DeleteLastProductByPVZAfterCounter returns a count of finished ReceptionRepositoryMock.DeleteLastProductByPVZ invocations
func (mmDeleteLastProductByPVZ *ReceptionRepositoryMock) DeleteLastProductByPVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteLastProductByPVZ.afterDeleteLastProductByPVZCounter)
}

// DeleteLastProductByPVZBeforeCounter returns a count of ReceptionRepositoryMock.DeleteLastProductByPVZ invocations
func (mmDeleteLastProductByPVZ *ReceptionRepositoryMock) DeleteLastProductByPVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteLastProductByPVZ.beforeDeleteLastProductByPVZCounter)
}

// Calls returns a list of arguments used in each call to ReceptionRepositoryMock.DeleteLastProductByPVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteLastProductByPVZ *mReceptionRepositoryMockDeleteLastProductByPVZ) Calls() []*ReceptionRepositoryMockDeleteLastProductByPVZParams {
	mmDeleteLastProductByPVZ.mutex.RLock()

	argCopy := make([]*ReceptionRepositoryMockDeleteLastProductByPVZParams, len(mmDeleteLastProductByPVZ.callArgs))
	copy(argCopy, mmDeleteLastProductByPVZ.callArgs)

	mmDeleteLastProductByPVZ.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteLastProductByPVZDone returns true if the count of the DeleteLastProductByPVZ invocations corresponds
// the number of defined expectations
func (m *ReceptionRepositoryMock) MinimockDeleteLastProductByPVZDone() bool {
	if m.DeleteLastProductByPVZMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteLastProductByPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteLastProductByPVZMock.invocationsDone()
}

// MinimockDeleteLastProductByPVZInspect logs each unmet expectation
func (m *ReceptionRepositoryMock) MinimockDeleteLastProductByPVZInspect() {
	for _, e := range m.DeleteLastProductByPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.DeleteLastProductByPVZ at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteLastProductByPVZCounter := mm_atomic.LoadUint64(&m.afterDeleteLastProductByPVZCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteLastProductByPVZMock.defaultExpectation != nil && afterDeleteLastProductByPVZCounter < 1 {
		if m.DeleteLastProductByPVZMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.DeleteLastProductByPVZ at\n%s", m.DeleteLastProductByPVZMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.DeleteLastProductByPVZ at\n%s with params: %#v", m.DeleteLastProductByPVZMock.defaultExpectation.expectationOrigins.origin, *m.DeleteLastProductByPVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteLastProductByPVZ != nil && afterDeleteLastProductByPVZCounter < 1 {
		m.t.Errorf("Expected call to ReceptionRepositoryMock.DeleteLastProductByPVZ at\n%s", m.funcDeleteLastProductByPVZOrigin)
	}

	if !m.DeleteLastProductByPVZMock.invocationsDone() && afterDeleteLastProductByPVZCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionRepositoryMock.DeleteLastProductByPVZ at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteLastProductByPVZMock.expectedInvocations), m.DeleteLastProductByPVZMock.expectedInvocationsOrigin, afterDeleteLastProductByPVZCounter)
	}
}

type mReceptionRepositoryMockGetOpenReceptionForPVZ struct {
	optional           bool
	mock               *ReceptionRepositoryMock
	defaultExpectation *ReceptionRepositoryMockGetOpenReceptionForPVZExpectation
	expectations       []*ReceptionRepositoryMockGetOpenReceptionForPVZExpectation

	callArgs []*ReceptionRepositoryMockGetOpenReceptionForPVZParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionRepositoryMockGetOpenReceptionForPVZExpectation specifies expectation struct of the ReceptionRepository.GetOpenReceptionForPVZ
type ReceptionRepositoryMockGetOpenReceptionForPVZExpectation struct {
	mock               *ReceptionRepositoryMock
	params             *ReceptionRepositoryMockGetOpenReceptionForPVZParams
	paramPtrs          *ReceptionRepositoryMockGetOpenReceptionForPVZParamPtrs
	expectationOrigins ReceptionRepositoryMockGetOpenReceptionForPVZExpectationOrigins
	results            *ReceptionRepositoryMockGetOpenReceptionForPVZResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionRepositoryMockGetOpenReceptionForPVZParams contains parameters of the ReceptionRepository.GetOpenReceptionForPVZ
type ReceptionRepositoryMockGetOpenReceptionForPVZParams struct {
	ctx   context.Context
	pvzID string
}

// ReceptionRepositoryMockGetOpenReceptionForPVZParamPtrs contains pointers to parameters of the ReceptionRepository.GetOpenReceptionForPVZ
type ReceptionRepositoryMockGetOpenReceptionForPVZParamPtrs struct {
	ctx   *context.Context
	pvzID *string
}

// ReceptionRepositoryMockGetOpenReceptionForPVZResults contains results of the ReceptionRepository.GetOpenReceptionForPVZ
type ReceptionRepositoryMockGetOpenReceptionForPVZResults struct {
	rp1 *model.Reception
	err error
}

// ReceptionRepositoryMockGetOpenReceptionForPVZOrigins contains origins of expectations of the ReceptionRepository.GetOpenReceptionForPVZ
type ReceptionRepositoryMockGetOpenReceptionForPVZExpectationOrigins struct {
	origin      string
	originCtx   string
	originPvzID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) Optional() *mReceptionRepositoryMockGetOpenReceptionForPVZ {
	mmGetOpenReceptionForPVZ.optional = true
	return mmGetOpenReceptionForPVZ
}

// Expect sets up expected params for ReceptionRepository.GetOpenReceptionForPVZ
func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) Expect(ctx context.Context, pvzID string) *mReceptionRepositoryMockGetOpenReceptionForPVZ {
	if mmGetOpenReceptionForPVZ.mock.funcGetOpenReceptionForPVZ != nil {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetOpenReceptionForPVZ mock is already set by Set")
	}

	if mmGetOpenReceptionForPVZ.defaultExpectation == nil {
		mmGetOpenReceptionForPVZ.defaultExpectation = &ReceptionRepositoryMockGetOpenReceptionForPVZExpectation{}
	}

	if mmGetOpenReceptionForPVZ.defaultExpectation.paramPtrs != nil {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetOpenReceptionForPVZ mock is already set by ExpectParams functions")
	}

	mmGetOpenReceptionForPVZ.defaultExpectation.params = &ReceptionRepositoryMockGetOpenReceptionForPVZParams{ctx, pvzID}
	mmGetOpenReceptionForPVZ.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOpenReceptionForPVZ.expectations {
		if minimock.Equal(e.params, mmGetOpenReceptionForPVZ.defaultExpectation.params) {
			mmGetOpenReceptionForPVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOpenReceptionForPVZ.defaultExpectation.params)
		}
	}

	return mmGetOpenReceptionForPVZ
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionRepository.GetOpenReceptionForPVZ
func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) ExpectCtxParam1(ctx context.Context) *mReceptionRepositoryMockGetOpenReceptionForPVZ {
	if mmGetOpenReceptionForPVZ.mock.funcGetOpenReceptionForPVZ != nil {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetOpenReceptionForPVZ mock is already set by Set")
	}

	if mmGetOpenReceptionForPVZ.defaultExpectation == nil {
		mmGetOpenReceptionForPVZ.defaultExpectation = &ReceptionRepositoryMockGetOpenReceptionForPVZExpectation{}
	}

	if mmGetOpenReceptionForPVZ.defaultExpectation.params != nil {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetOpenReceptionForPVZ mock is already set by Expect")
	}

	if mmGetOpenReceptionForPVZ.defaultExpectation.paramPtrs == nil {
		mmGetOpenReceptionForPVZ.defaultExpectation.paramPtrs = &ReceptionRepositoryMockGetOpenReceptionForPVZParamPtrs{}
	}
	mmGetOpenReceptionForPVZ.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOpenReceptionForPVZ.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOpenReceptionForPVZ
}

// ExpectPvzIDParam2 sets up expected param pvzID for ReceptionRepository.GetOpenReceptionForPVZ
func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) ExpectPvzIDParam2(pvzID string) *mReceptionRepositoryMockGetOpenReceptionForPVZ {
	if mmGetOpenReceptionForPVZ.mock.funcGetOpenReceptionForPVZ != nil {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetOpenReceptionForPVZ mock is already set by Set")
	}

	if mmGetOpenReceptionForPVZ.defaultExpectation == nil {
		mmGetOpenReceptionForPVZ.defaultExpectation = &ReceptionRepositoryMockGetOpenReceptionForPVZExpectation{}
	}

	if mmGetOpenReceptionForPVZ.defaultExpectation.params != nil {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetOpenReceptionForPVZ mock is already set by Expect")
	}

	if mmGetOpenReceptionForPVZ.defaultExpectation.paramPtrs == nil {
		mmGetOpenReceptionForPVZ.defaultExpectation.paramPtrs = &ReceptionRepositoryMockGetOpenReceptionForPVZParamPtrs{}
	}
	mmGetOpenReceptionForPVZ.defaultExpectation.paramPtrs.pvzID = &pvzID
	mmGetOpenReceptionForPVZ.defaultExpectation.expectationOrigins.originPvzID = minimock.CallerInfo(1)

	return mmGetOpenReceptionForPVZ
}

// Inspect accepts an inspector function that has same arguments as the ReceptionRepository.GetOpenReceptionForPVZ
func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) Inspect(f func(ctx context.Context, pvzID string)) *mReceptionRepositoryMockGetOpenReceptionForPVZ {
	if mmGetOpenReceptionForPVZ.mock.inspectFuncGetOpenReceptionForPVZ != nil {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("Inspect function is already set for ReceptionRepositoryMock.GetOpenReceptionForPVZ")
	}

	mmGetOpenReceptionForPVZ.mock.inspectFuncGetOpenReceptionForPVZ = f

	return mmGetOpenReceptionForPVZ
}

// Return sets up results that will be returned by ReceptionRepository.GetOpenReceptionForPVZ
func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) Return(rp1 *model.Reception, err error) *ReceptionRepositoryMock {
	if mmGetOpenReceptionForPVZ.mock.funcGetOpenReceptionForPVZ != nil {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetOpenReceptionForPVZ mock is already set by Set")
	}

	if mmGetOpenReceptionForPVZ.defaultExpectation == nil {
		mmGetOpenReceptionForPVZ.defaultExpectation = &ReceptionRepositoryMockGetOpenReceptionForPVZExpectation{mock: mmGetOpenReceptionForPVZ.mock}
	}
	mmGetOpenReceptionForPVZ.defaultExpectation.results = &ReceptionRepositoryMockGetOpenReceptionForPVZResults{rp1, err}
	mmGetOpenReceptionForPVZ.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOpenReceptionForPVZ.mock
}

// Set uses given function f to mock the ReceptionRepository.GetOpenReceptionForPVZ method
func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) Set(f func(ctx context.Context, pvzID string) (rp1 *model.Reception, err error)) *ReceptionRepositoryMock {
	if mmGetOpenReceptionForPVZ.defaultExpectation != nil {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("Default expectation is already set for the ReceptionRepository.GetOpenReceptionForPVZ method")
	}

	if len(mmGetOpenReceptionForPVZ.expectations) > 0 {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("Some expectations are already set for the ReceptionRepository.GetOpenReceptionForPVZ method")
	}

	mmGetOpenReceptionForPVZ.mock.funcGetOpenReceptionForPVZ = f
	mmGetOpenReceptionForPVZ.mock.funcGetOpenReceptionForPVZOrigin = minimock.CallerInfo(1)
	return mmGetOpenReceptionForPVZ.mock
}

// When sets expectation for the ReceptionRepository.GetOpenReceptionForPVZ which will trigger the result defined by the following
// Then helper
func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) When(ctx context.Context, pvzID string) *ReceptionRepositoryMockGetOpenReceptionForPVZExpectation {
	if mmGetOpenReceptionForPVZ.mock.funcGetOpenReceptionForPVZ != nil {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetOpenReceptionForPVZ mock is already set by Set")
	}

	expectation := &ReceptionRepositoryMockGetOpenReceptionForPVZExpectation{
		mock:               mmGetOpenReceptionForPVZ.mock,
		params:             &ReceptionRepositoryMockGetOpenReceptionForPVZParams{ctx, pvzID},
		expectationOrigins: ReceptionRepositoryMockGetOpenReceptionForPVZExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOpenReceptionForPVZ.expectations = append(mmGetOpenReceptionForPVZ.expectations, expectation)
	return expectation
}

// Then sets up ReceptionRepository.GetOpenReceptionForPVZ return parameters for the expectation previously defined by the When method
func (e *ReceptionRepositoryMockGetOpenReceptionForPVZExpectation) Then(rp1 *model.Reception, err error) *ReceptionRepositoryMock {
	e.results = &ReceptionRepositoryMockGetOpenReceptionForPVZResults{rp1, err}
	return e.mock
}

// Times sets number of times ReceptionRepository.GetOpenReceptionForPVZ should be invoked
func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) Times(n uint64) *mReceptionRepositoryMockGetOpenReceptionForPVZ {
	if n == 0 {
		mmGetOpenReceptionForPVZ.mock.t.Fatalf("Times of ReceptionRepositoryMock.GetOpenReceptionForPVZ mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOpenReceptionForPVZ.expectedInvocations, n)
	mmGetOpenReceptionForPVZ.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOpenReceptionForPVZ
}

func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) invocationsDone() bool {
	if len(mmGetOpenReceptionForPVZ.expectations) == 0 && mmGetOpenReceptionForPVZ.defaultExpectation == nil && mmGetOpenReceptionForPVZ.mock.funcGetOpenReceptionForPVZ == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOpenReceptionForPVZ.mock.afterGetOpenReceptionForPVZCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOpenReceptionForPVZ.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOpenReceptionForPVZ implements mm_repository.ReceptionRepository
func (mmGetOpenReceptionForPVZ *ReceptionRepositoryMock) GetOpenReceptionForPVZ(ctx context.Context, pvzID string) (rp1 *model.Reception, err error) {
	mm_atomic.AddUint64(&mmGetOpenReceptionForPVZ.beforeGetOpenReceptionForPVZCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOpenReceptionForPVZ.afterGetOpenReceptionForPVZCounter, 1)

	mmGetOpenReceptionForPVZ.t.Helper()

	if mmGetOpenReceptionForPVZ.inspectFuncGetOpenReceptionForPVZ != nil {
		mmGetOpenReceptionForPVZ.inspectFuncGetOpenReceptionForPVZ(ctx, pvzID)
	}

	mm_params := ReceptionRepositoryMockGetOpenReceptionForPVZParams{ctx, pvzID}

	// Record call args
	mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.mutex.Lock()
	mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.callArgs = append(mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.callArgs, &mm_params)
	mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.mutex.Unlock()

	for _, e := range mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.defaultExpectation.params
		mm_want_ptrs := mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.defaultExpectation.paramPtrs

		mm_got := ReceptionRepositoryMockGetOpenReceptionForPVZParams{ctx, pvzID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOpenReceptionForPVZ.t.Errorf("ReceptionRepositoryMock.GetOpenReceptionForPVZ got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzID != nil && !minimock.Equal(*mm_want_ptrs.pvzID, mm_got.pvzID) {
				mmGetOpenReceptionForPVZ.t.Errorf("ReceptionRepositoryMock.GetOpenReceptionForPVZ got unexpected parameter pvzID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.defaultExpectation.expectationOrigins.originPvzID, *mm_want_ptrs.pvzID, mm_got.pvzID, minimock.Diff(*mm_want_ptrs.pvzID, mm_got.pvzID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOpenReceptionForPVZ.t.Errorf("ReceptionRepositoryMock.GetOpenReceptionForPVZ got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOpenReceptionForPVZ.GetOpenReceptionForPVZMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOpenReceptionForPVZ.t.Fatal("No results are set for the ReceptionRepositoryMock.GetOpenReceptionForPVZ")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetOpenReceptionForPVZ.funcGetOpenReceptionForPVZ != nil {
		return mmGetOpenReceptionForPVZ.funcGetOpenReceptionForPVZ(ctx, pvzID)
	}
	mmGetOpenReceptionForPVZ.t.Fatalf("Unexpected call to ReceptionRepositoryMock.GetOpenReceptionForPVZ. %v %v", ctx, pvzID)
	return
}

// GetOpenReceptionForPVZAfterCounter returns a count of finished ReceptionRepositoryMock.GetOpenReceptionForPVZ invocations
func (mmGetOpenReceptionForPVZ *ReceptionRepositoryMock) GetOpenReceptionForPVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOpenReceptionForPVZ.afterGetOpenReceptionForPVZCounter)
}

// GetOpenReceptionForPVZBeforeCounter returns a count of ReceptionRepositoryMock.GetOpenReceptionForPVZ invocations
func (mmGetOpenReceptionForPVZ *ReceptionRepositoryMock) GetOpenReceptionForPVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOpenReceptionForPVZ.beforeGetOpenReceptionForPVZCounter)
}

// Calls returns a list of arguments used in each call to ReceptionRepositoryMock.GetOpenReceptionForPVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOpenReceptionForPVZ *mReceptionRepositoryMockGetOpenReceptionForPVZ) Calls() []*ReceptionRepositoryMockGetOpenReceptionForPVZParams {
	mmGetOpenReceptionForPVZ.mutex.RLock()

	argCopy := make([]*ReceptionRepositoryMockGetOpenReceptionForPVZParams, len(mmGetOpenReceptionForPVZ.callArgs))
	copy(argCopy, mmGetOpenReceptionForPVZ.callArgs)

	mmGetOpenReceptionForPVZ.mutex.RUnlock()

	return argCopy
}

// MinimockGetOpenReceptionForPVZDone returns true if the count of the GetOpenReceptionForPVZ invocations corresponds
// the number of defined expectations
func (m *ReceptionRepositoryMock) MinimockGetOpenReceptionForPVZDone() bool {
	if m.GetOpenReceptionForPVZMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOpenReceptionForPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOpenReceptionForPVZMock.invocationsDone()
}

// MinimockGetOpenReceptionForPVZInspect logs each unmet expectation
func (m *ReceptionRepositoryMock) MinimockGetOpenReceptionForPVZInspect() {
	for _, e := range m.GetOpenReceptionForPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.GetOpenReceptionForPVZ at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOpenReceptionForPVZCounter := mm_atomic.LoadUint64(&m.afterGetOpenReceptionForPVZCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOpenReceptionForPVZMock.defaultExpectation != nil && afterGetOpenReceptionForPVZCounter < 1 {
		if m.GetOpenReceptionForPVZMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.GetOpenReceptionForPVZ at\n%s", m.GetOpenReceptionForPVZMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.GetOpenReceptionForPVZ at\n%s with params: %#v", m.GetOpenReceptionForPVZMock.defaultExpectation.expectationOrigins.origin, *m.GetOpenReceptionForPVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOpenReceptionForPVZ != nil && afterGetOpenReceptionForPVZCounter < 1 {
		m.t.Errorf("Expected call to ReceptionRepositoryMock.GetOpenReceptionForPVZ at\n%s", m.funcGetOpenReceptionForPVZOrigin)
	}

	if !m.GetOpenReceptionForPVZMock.invocationsDone() && afterGetOpenReceptionForPVZCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionRepositoryMock.GetOpenReceptionForPVZ at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOpenReceptionForPVZMock.expectedInvocations), m.GetOpenReceptionForPVZMock.expectedInvocationsOrigin, afterGetOpenReceptionForPVZCounter)
	}
}

type mReceptionRepositoryMockGetProductsByReception struct {
	optional           bool
	mock               *ReceptionRepositoryMock
	defaultExpectation *ReceptionRepositoryMockGetProductsByReceptionExpectation
	expectations       []*ReceptionRepositoryMockGetProductsByReceptionExpectation

	callArgs []*ReceptionRepositoryMockGetProductsByReceptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionRepositoryMockGetProductsByReceptionExpectation specifies expectation struct of the ReceptionRepository.GetProductsByReception
type ReceptionRepositoryMockGetProductsByReceptionExpectation struct {
	mock               *ReceptionRepositoryMock
	params             *ReceptionRepositoryMockGetProductsByReceptionParams
	paramPtrs          *ReceptionRepositoryMockGetProductsByReceptionParamPtrs
	expectationOrigins ReceptionRepositoryMockGetProductsByReceptionExpectationOrigins
	results            *ReceptionRepositoryMockGetProductsByReceptionResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionRepositoryMockGetProductsByReceptionParams contains parameters of the ReceptionRepository.GetProductsByReception
type ReceptionRepositoryMockGetProductsByReceptionParams struct {
	ctx         context.Context
	receptionID string
}

// ReceptionRepositoryMockGetProductsByReceptionParamPtrs contains pointers to parameters of the ReceptionRepository.GetProductsByReception
type ReceptionRepositoryMockGetProductsByReceptionParamPtrs struct {
	ctx         *context.Context
	receptionID *string
}

// ReceptionRepositoryMockGetProductsByReceptionResults contains results of the ReceptionRepository.GetProductsByReception
type ReceptionRepositoryMockGetProductsByReceptionResults struct {
	ppa1 []*model.Product
	err  error
}

// ReceptionRepositoryMockGetProductsByReceptionOrigins contains origins of expectations of the ReceptionRepository.GetProductsByReception
type ReceptionRepositoryMockGetProductsByReceptionExpectationOrigins struct {
	origin            string
	originCtx         string
	originReceptionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) Optional() *mReceptionRepositoryMockGetProductsByReception {
	mmGetProductsByReception.optional = true
	return mmGetProductsByReception
}

// Expect sets up expected params for ReceptionRepository.GetProductsByReception
func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) Expect(ctx context.Context, receptionID string) *mReceptionRepositoryMockGetProductsByReception {
	if mmGetProductsByReception.mock.funcGetProductsByReception != nil {
		mmGetProductsByReception.mock.t.Fatalf("ReceptionRepositoryMock.GetProductsByReception mock is already set by Set")
	}

	if mmGetProductsByReception.defaultExpectation == nil {
		mmGetProductsByReception.defaultExpectation = &ReceptionRepositoryMockGetProductsByReceptionExpectation{}
	}

	if mmGetProductsByReception.defaultExpectation.paramPtrs != nil {
		mmGetProductsByReception.mock.t.Fatalf("ReceptionRepositoryMock.GetProductsByReception mock is already set by ExpectParams functions")
	}

	mmGetProductsByReception.defaultExpectation.params = &ReceptionRepositoryMockGetProductsByReceptionParams{ctx, receptionID}
	mmGetProductsByReception.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetProductsByReception.expectations {
		if minimock.Equal(e.params, mmGetProductsByReception.defaultExpectation.params) {
			mmGetProductsByReception.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProductsByReception.defaultExpectation.params)
		}
	}

	return mmGetProductsByReception
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionRepository.GetProductsByReception
func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) ExpectCtxParam1(ctx context.Context) *mReceptionRepositoryMockGetProductsByReception {
	if mmGetProductsByReception.mock.funcGetProductsByReception != nil {
		mmGetProductsByReception.mock.t.Fatalf("ReceptionRepositoryMock.GetProductsByReception mock is already set by Set")
	}

	if mmGetProductsByReception.defaultExpectation == nil {
		mmGetProductsByReception.defaultExpectation = &ReceptionRepositoryMockGetProductsByReceptionExpectation{}
	}

	if mmGetProductsByReception.defaultExpectation.params != nil {
		mmGetProductsByReception.mock.t.Fatalf("ReceptionRepositoryMock.GetProductsByReception mock is already set by Expect")
	}

	if mmGetProductsByReception.defaultExpectation.paramPtrs == nil {
		mmGetProductsByReception.defaultExpectation.paramPtrs = &ReceptionRepositoryMockGetProductsByReceptionParamPtrs{}
	}
	mmGetProductsByReception.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetProductsByReception.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetProductsByReception
}

// ExpectReceptionIDParam2 sets up expected param receptionID for ReceptionRepository.GetProductsByReception
func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) ExpectReceptionIDParam2(receptionID string) *mReceptionRepositoryMockGetProductsByReception {
	if mmGetProductsByReception.mock.funcGetProductsByReception != nil {
		mmGetProductsByReception.mock.t.Fatalf("ReceptionRepositoryMock.GetProductsByReception mock is already set by Set")
	}

	if mmGetProductsByReception.defaultExpectation == nil {
		mmGetProductsByReception.defaultExpectation = &ReceptionRepositoryMockGetProductsByReceptionExpectation{}
	}

	if mmGetProductsByReception.defaultExpectation.params != nil {
		mmGetProductsByReception.mock.t.Fatalf("ReceptionRepositoryMock.GetProductsByReception mock is already set by Expect")
	}

	if mmGetProductsByReception.defaultExpectation.paramPtrs == nil {
		mmGetProductsByReception.defaultExpectation.paramPtrs = &ReceptionRepositoryMockGetProductsByReceptionParamPtrs{}
	}
	mmGetProductsByReception.defaultExpectation.paramPtrs.receptionID = &receptionID
	mmGetProductsByReception.defaultExpectation.expectationOrigins.originReceptionID = minimock.CallerInfo(1)

	return mmGetProductsByReception
}

// Inspect accepts an inspector function that has same arguments as the ReceptionRepository.GetProductsByReception
func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) Inspect(f func(ctx context.Context, receptionID string)) *mReceptionRepositoryMockGetProductsByReception {
	if mmGetProductsByReception.mock.inspectFuncGetProductsByReception != nil {
		mmGetProductsByReception.mock.t.Fatalf("Inspect function is already set for ReceptionRepositoryMock.GetProductsByReception")
	}

	mmGetProductsByReception.mock.inspectFuncGetProductsByReception = f

	return mmGetProductsByReception
}

// Return sets up results that will be returned by ReceptionRepository.GetProductsByReception
func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) Return(ppa1 []*model.Product, err error) *ReceptionRepositoryMock {
	if mmGetProductsByReception.mock.funcGetProductsByReception != nil {
		mmGetProductsByReception.mock.t.Fatalf("ReceptionRepositoryMock.GetProductsByReception mock is already set by Set")
	}

	if mmGetProductsByReception.defaultExpectation == nil {
		mmGetProductsByReception.defaultExpectation = &ReceptionRepositoryMockGetProductsByReceptionExpectation{mock: mmGetProductsByReception.mock}
	}
	mmGetProductsByReception.defaultExpectation.results = &ReceptionRepositoryMockGetProductsByReceptionResults{ppa1, err}
	mmGetProductsByReception.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetProductsByReception.mock
}

// Set uses given function f to mock the ReceptionRepository.GetProductsByReception method
func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) Set(f func(ctx context.Context, receptionID string) (ppa1 []*model.Product, err error)) *ReceptionRepositoryMock {
	if mmGetProductsByReception.defaultExpectation != nil {
		mmGetProductsByReception.mock.t.Fatalf("Default expectation is already set for the ReceptionRepository.GetProductsByReception method")
	}

	if len(mmGetProductsByReception.expectations) > 0 {
		mmGetProductsByReception.mock.t.Fatalf("Some expectations are already set for the ReceptionRepository.GetProductsByReception method")
	}

	mmGetProductsByReception.mock.funcGetProductsByReception = f
	mmGetProductsByReception.mock.funcGetProductsByReceptionOrigin = minimock.CallerInfo(1)
	return mmGetProductsByReception.mock
}

// When sets expectation for the ReceptionRepository.GetProductsByReception which will trigger the result defined by the following
// Then helper
func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) When(ctx context.Context, receptionID string) *ReceptionRepositoryMockGetProductsByReceptionExpectation {
	if mmGetProductsByReception.mock.funcGetProductsByReception != nil {
		mmGetProductsByReception.mock.t.Fatalf("ReceptionRepositoryMock.GetProductsByReception mock is already set by Set")
	}

	expectation := &ReceptionRepositoryMockGetProductsByReceptionExpectation{
		mock:               mmGetProductsByReception.mock,
		params:             &ReceptionRepositoryMockGetProductsByReceptionParams{ctx, receptionID},
		expectationOrigins: ReceptionRepositoryMockGetProductsByReceptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetProductsByReception.expectations = append(mmGetProductsByReception.expectations, expectation)
	return expectation
}

// Then sets up ReceptionRepository.GetProductsByReception return parameters for the expectation previously defined by the When method
func (e *ReceptionRepositoryMockGetProductsByReceptionExpectation) Then(ppa1 []*model.Product, err error) *ReceptionRepositoryMock {
	e.results = &ReceptionRepositoryMockGetProductsByReceptionResults{ppa1, err}
	return e.mock
}

// Times sets number of times ReceptionRepository.GetProductsByReception should be invoked
func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) Times(n uint64) *mReceptionRepositoryMockGetProductsByReception {
	if n == 0 {
		mmGetProductsByReception.mock.t.Fatalf("Times of ReceptionRepositoryMock.GetProductsByReception mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetProductsByReception.expectedInvocations, n)
	mmGetProductsByReception.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetProductsByReception
}

func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) invocationsDone() bool {
	if len(mmGetProductsByReception.expectations) == 0 && mmGetProductsByReception.defaultExpectation == nil && mmGetProductsByReception.mock.funcGetProductsByReception == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetProductsByReception.mock.afterGetProductsByReceptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetProductsByReception.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetProductsByReception implements mm_repository.ReceptionRepository
func (mmGetProductsByReception *ReceptionRepositoryMock) GetProductsByReception(ctx context.Context, receptionID string) (ppa1 []*model.Product, err error) {
	mm_atomic.AddUint64(&mmGetProductsByReception.beforeGetProductsByReceptionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProductsByReception.afterGetProductsByReceptionCounter, 1)

	mmGetProductsByReception.t.Helper()

	if mmGetProductsByReception.inspectFuncGetProductsByReception != nil {
		mmGetProductsByReception.inspectFuncGetProductsByReception(ctx, receptionID)
	}

	mm_params := ReceptionRepositoryMockGetProductsByReceptionParams{ctx, receptionID}

	// Record call args
	mmGetProductsByReception.GetProductsByReceptionMock.mutex.Lock()
	mmGetProductsByReception.GetProductsByReceptionMock.callArgs = append(mmGetProductsByReception.GetProductsByReceptionMock.callArgs, &mm_params)
	mmGetProductsByReception.GetProductsByReceptionMock.mutex.Unlock()

	for _, e := range mmGetProductsByReception.GetProductsByReceptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmGetProductsByReception.GetProductsByReceptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProductsByReception.GetProductsByReceptionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProductsByReception.GetProductsByReceptionMock.defaultExpectation.params
		mm_want_ptrs := mmGetProductsByReception.GetProductsByReceptionMock.defaultExpectation.paramPtrs

		mm_got := ReceptionRepositoryMockGetProductsByReceptionParams{ctx, receptionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetProductsByReception.t.Errorf("ReceptionRepositoryMock.GetProductsByReception got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProductsByReception.GetProductsByReceptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.receptionID != nil && !minimock.Equal(*mm_want_ptrs.receptionID, mm_got.receptionID) {
				mmGetProductsByReception.t.Errorf("ReceptionRepositoryMock.GetProductsByReception got unexpected parameter receptionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProductsByReception.GetProductsByReceptionMock.defaultExpectation.expectationOrigins.originReceptionID, *mm_want_ptrs.receptionID, mm_got.receptionID, minimock.Diff(*mm_want_ptrs.receptionID, mm_got.receptionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProductsByReception.t.Errorf("ReceptionRepositoryMock.GetProductsByReception got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetProductsByReception.GetProductsByReceptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProductsByReception.GetProductsByReceptionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProductsByReception.t.Fatal("No results are set for the ReceptionRepositoryMock.GetProductsByReception")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmGetProductsByReception.funcGetProductsByReception != nil {
		return mmGetProductsByReception.funcGetProductsByReception(ctx, receptionID)
	}
	mmGetProductsByReception.t.Fatalf("Unexpected call to ReceptionRepositoryMock.GetProductsByReception. %v %v", ctx, receptionID)
	return
}

// GetProductsByReceptionAfterCounter returns a count of finished ReceptionRepositoryMock.GetProductsByReception invocations
func (mmGetProductsByReception *ReceptionRepositoryMock) GetProductsByReceptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProductsByReception.afterGetProductsByReceptionCounter)
}

// GetProductsByReceptionBeforeCounter returns a count of ReceptionRepositoryMock.GetProductsByReception invocations
func (mmGetProductsByReception *ReceptionRepositoryMock) GetProductsByReceptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProductsByReception.beforeGetProductsByReceptionCounter)
}

// Calls returns a list of arguments used in each call to ReceptionRepositoryMock.GetProductsByReception.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProductsByReception *mReceptionRepositoryMockGetProductsByReception) Calls() []*ReceptionRepositoryMockGetProductsByReceptionParams {
	mmGetProductsByReception.mutex.RLock()

	argCopy := make([]*ReceptionRepositoryMockGetProductsByReceptionParams, len(mmGetProductsByReception.callArgs))
	copy(argCopy, mmGetProductsByReception.callArgs)

	mmGetProductsByReception.mutex.RUnlock()

	return argCopy
}

// MinimockGetProductsByReceptionDone returns true if the count of the GetProductsByReception invocations corresponds
// the number of defined expectations
func (m *ReceptionRepositoryMock) MinimockGetProductsByReceptionDone() bool {
	if m.GetProductsByReceptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetProductsByReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetProductsByReceptionMock.invocationsDone()
}

// MinimockGetProductsByReceptionInspect logs each unmet expectation
func (m *ReceptionRepositoryMock) MinimockGetProductsByReceptionInspect() {
	for _, e := range m.GetProductsByReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.GetProductsByReception at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetProductsByReceptionCounter := mm_atomic.LoadUint64(&m.afterGetProductsByReceptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductsByReceptionMock.defaultExpectation != nil && afterGetProductsByReceptionCounter < 1 {
		if m.GetProductsByReceptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.GetProductsByReception at\n%s", m.GetProductsByReceptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.GetProductsByReception at\n%s with params: %#v", m.GetProductsByReceptionMock.defaultExpectation.expectationOrigins.origin, *m.GetProductsByReceptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProductsByReception != nil && afterGetProductsByReceptionCounter < 1 {
		m.t.Errorf("Expected call to ReceptionRepositoryMock.GetProductsByReception at\n%s", m.funcGetProductsByReceptionOrigin)
	}

	if !m.GetProductsByReceptionMock.invocationsDone() && afterGetProductsByReceptionCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionRepositoryMock.GetProductsByReception at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetProductsByReceptionMock.expectedInvocations), m.GetProductsByReceptionMock.expectedInvocationsOrigin, afterGetProductsByReceptionCounter)
	}
}

type mReceptionRepositoryMockGetReceptionsByPVZ struct {
	optional           bool
	mock               *ReceptionRepositoryMock
	defaultExpectation *ReceptionRepositoryMockGetReceptionsByPVZExpectation
	expectations       []*ReceptionRepositoryMockGetReceptionsByPVZExpectation

	callArgs []*ReceptionRepositoryMockGetReceptionsByPVZParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionRepositoryMockGetReceptionsByPVZExpectation specifies expectation struct of the ReceptionRepository.GetReceptionsByPVZ
type ReceptionRepositoryMockGetReceptionsByPVZExpectation struct {
	mock               *ReceptionRepositoryMock
	params             *ReceptionRepositoryMockGetReceptionsByPVZParams
	paramPtrs          *ReceptionRepositoryMockGetReceptionsByPVZParamPtrs
	expectationOrigins ReceptionRepositoryMockGetReceptionsByPVZExpectationOrigins
	results            *ReceptionRepositoryMockGetReceptionsByPVZResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionRepositoryMockGetReceptionsByPVZParams contains parameters of the ReceptionRepository.GetReceptionsByPVZ
type ReceptionRepositoryMockGetReceptionsByPVZParams struct {
	ctx       context.Context
	pvzID     string
	startDate *string
	endDate   *string
}

// ReceptionRepositoryMockGetReceptionsByPVZParamPtrs contains pointers to parameters of the ReceptionRepository.GetReceptionsByPVZ
type ReceptionRepositoryMockGetReceptionsByPVZParamPtrs struct {
	ctx       *context.Context
	pvzID     *string
	startDate **string
	endDate   **string
}

// ReceptionRepositoryMockGetReceptionsByPVZResults contains results of the ReceptionRepository.GetReceptionsByPVZ
type ReceptionRepositoryMockGetReceptionsByPVZResults struct {
	rpa1 []*model.Reception
	err  error
}

// ReceptionRepositoryMockGetReceptionsByPVZOrigins contains origins of expectations of the ReceptionRepository.GetReceptionsByPVZ
type ReceptionRepositoryMockGetReceptionsByPVZExpectationOrigins struct {
	origin          string
	originCtx       string
	originPvzID     string
	originStartDate string
	originEndDate   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) Optional() *mReceptionRepositoryMockGetReceptionsByPVZ {
	mmGetReceptionsByPVZ.optional = true
	return mmGetReceptionsByPVZ
}

// Expect sets up expected params for ReceptionRepository.GetReceptionsByPVZ
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) Expect(ctx context.Context, pvzID string, startDate *string, endDate *string) *mReceptionRepositoryMockGetReceptionsByPVZ {
	if mmGetReceptionsByPVZ.mock.funcGetReceptionsByPVZ != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Set")
	}

	if mmGetReceptionsByPVZ.defaultExpectation == nil {
		mmGetReceptionsByPVZ.defaultExpectation = &ReceptionRepositoryMockGetReceptionsByPVZExpectation{}
	}

	if mmGetReceptionsByPVZ.defaultExpectation.paramPtrs != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by ExpectParams functions")
	}

	mmGetReceptionsByPVZ.defaultExpectation.params = &ReceptionRepositoryMockGetReceptionsByPVZParams{ctx, pvzID, startDate, endDate}
	mmGetReceptionsByPVZ.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReceptionsByPVZ.expectations {
		if minimock.Equal(e.params, mmGetReceptionsByPVZ.defaultExpectation.params) {
			mmGetReceptionsByPVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReceptionsByPVZ.defaultExpectation.params)
		}
	}

	return mmGetReceptionsByPVZ
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionRepository.GetReceptionsByPVZ
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) ExpectCtxParam1(ctx context.Context) *mReceptionRepositoryMockGetReceptionsByPVZ {
	if mmGetReceptionsByPVZ.mock.funcGetReceptionsByPVZ != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Set")
	}

	if mmGetReceptionsByPVZ.defaultExpectation == nil {
		mmGetReceptionsByPVZ.defaultExpectation = &ReceptionRepositoryMockGetReceptionsByPVZExpectation{}
	}

	if mmGetReceptionsByPVZ.defaultExpectation.params != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Expect")
	}

	if mmGetReceptionsByPVZ.defaultExpectation.paramPtrs == nil {
		mmGetReceptionsByPVZ.defaultExpectation.paramPtrs = &ReceptionRepositoryMockGetReceptionsByPVZParamPtrs{}
	}
	mmGetReceptionsByPVZ.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReceptionsByPVZ.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReceptionsByPVZ
}

// ExpectPvzIDParam2 sets up expected param pvzID for ReceptionRepository.GetReceptionsByPVZ
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) ExpectPvzIDParam2(pvzID string) *mReceptionRepositoryMockGetReceptionsByPVZ {
	if mmGetReceptionsByPVZ.mock.funcGetReceptionsByPVZ != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Set")
	}

	if mmGetReceptionsByPVZ.defaultExpectation == nil {
		mmGetReceptionsByPVZ.defaultExpectation = &ReceptionRepositoryMockGetReceptionsByPVZExpectation{}
	}

	if mmGetReceptionsByPVZ.defaultExpectation.params != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Expect")
	}

	if mmGetReceptionsByPVZ.defaultExpectation.paramPtrs == nil {
		mmGetReceptionsByPVZ.defaultExpectation.paramPtrs = &ReceptionRepositoryMockGetReceptionsByPVZParamPtrs{}
	}
	mmGetReceptionsByPVZ.defaultExpectation.paramPtrs.pvzID = &pvzID
	mmGetReceptionsByPVZ.defaultExpectation.expectationOrigins.originPvzID = minimock.CallerInfo(1)

	return mmGetReceptionsByPVZ
}

// ExpectStartDateParam3 sets up expected param startDate for ReceptionRepository.GetReceptionsByPVZ
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) ExpectStartDateParam3(startDate *string) *mReceptionRepositoryMockGetReceptionsByPVZ {
	if mmGetReceptionsByPVZ.mock.funcGetReceptionsByPVZ != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Set")
	}

	if mmGetReceptionsByPVZ.defaultExpectation == nil {
		mmGetReceptionsByPVZ.defaultExpectation = &ReceptionRepositoryMockGetReceptionsByPVZExpectation{}
	}

	if mmGetReceptionsByPVZ.defaultExpectation.params != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Expect")
	}

	if mmGetReceptionsByPVZ.defaultExpectation.paramPtrs == nil {
		mmGetReceptionsByPVZ.defaultExpectation.paramPtrs = &ReceptionRepositoryMockGetReceptionsByPVZParamPtrs{}
	}
	mmGetReceptionsByPVZ.defaultExpectation.paramPtrs.startDate = &startDate
	mmGetReceptionsByPVZ.defaultExpectation.expectationOrigins.originStartDate = minimock.CallerInfo(1)

	return mmGetReceptionsByPVZ
}

// ExpectEndDateParam4 sets up expected param endDate for ReceptionRepository.GetReceptionsByPVZ
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) ExpectEndDateParam4(endDate *string) *mReceptionRepositoryMockGetReceptionsByPVZ {
	if mmGetReceptionsByPVZ.mock.funcGetReceptionsByPVZ != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Set")
	}

	if mmGetReceptionsByPVZ.defaultExpectation == nil {
		mmGetReceptionsByPVZ.defaultExpectation = &ReceptionRepositoryMockGetReceptionsByPVZExpectation{}
	}

	if mmGetReceptionsByPVZ.defaultExpectation.params != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Expect")
	}

	if mmGetReceptionsByPVZ.defaultExpectation.paramPtrs == nil {
		mmGetReceptionsByPVZ.defaultExpectation.paramPtrs = &ReceptionRepositoryMockGetReceptionsByPVZParamPtrs{}
	}
	mmGetReceptionsByPVZ.defaultExpectation.paramPtrs.endDate = &endDate
	mmGetReceptionsByPVZ.defaultExpectation.expectationOrigins.originEndDate = minimock.CallerInfo(1)

	return mmGetReceptionsByPVZ
}

// Inspect accepts an inspector function that has same arguments as the ReceptionRepository.GetReceptionsByPVZ
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) Inspect(f func(ctx context.Context, pvzID string, startDate *string, endDate *string)) *mReceptionRepositoryMockGetReceptionsByPVZ {
	if mmGetReceptionsByPVZ.mock.inspectFuncGetReceptionsByPVZ != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("Inspect function is already set for ReceptionRepositoryMock.GetReceptionsByPVZ")
	}

	mmGetReceptionsByPVZ.mock.inspectFuncGetReceptionsByPVZ = f

	return mmGetReceptionsByPVZ
}

// Return sets up results that will be returned by ReceptionRepository.GetReceptionsByPVZ
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) Return(rpa1 []*model.Reception, err error) *ReceptionRepositoryMock {
	if mmGetReceptionsByPVZ.mock.funcGetReceptionsByPVZ != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Set")
	}

	if mmGetReceptionsByPVZ.defaultExpectation == nil {
		mmGetReceptionsByPVZ.defaultExpectation = &ReceptionRepositoryMockGetReceptionsByPVZExpectation{mock: mmGetReceptionsByPVZ.mock}
	}
	mmGetReceptionsByPVZ.defaultExpectation.results = &ReceptionRepositoryMockGetReceptionsByPVZResults{rpa1, err}
	mmGetReceptionsByPVZ.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReceptionsByPVZ.mock
}

// Set uses given function f to mock the ReceptionRepository.GetReceptionsByPVZ method
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) Set(f func(ctx context.Context, pvzID string, startDate *string, endDate *string) (rpa1 []*model.Reception, err error)) *ReceptionRepositoryMock {
	if mmGetReceptionsByPVZ.defaultExpectation != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("Default expectation is already set for the ReceptionRepository.GetReceptionsByPVZ method")
	}

	if len(mmGetReceptionsByPVZ.expectations) > 0 {
		mmGetReceptionsByPVZ.mock.t.Fatalf("Some expectations are already set for the ReceptionRepository.GetReceptionsByPVZ method")
	}

	mmGetReceptionsByPVZ.mock.funcGetReceptionsByPVZ = f
	mmGetReceptionsByPVZ.mock.funcGetReceptionsByPVZOrigin = minimock.CallerInfo(1)
	return mmGetReceptionsByPVZ.mock
}

// When sets expectation for the ReceptionRepository.GetReceptionsByPVZ which will trigger the result defined by the following
// Then helper
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) When(ctx context.Context, pvzID string, startDate *string, endDate *string) *ReceptionRepositoryMockGetReceptionsByPVZExpectation {
	if mmGetReceptionsByPVZ.mock.funcGetReceptionsByPVZ != nil {
		mmGetReceptionsByPVZ.mock.t.Fatalf("ReceptionRepositoryMock.GetReceptionsByPVZ mock is already set by Set")
	}

	expectation := &ReceptionRepositoryMockGetReceptionsByPVZExpectation{
		mock:               mmGetReceptionsByPVZ.mock,
		params:             &ReceptionRepositoryMockGetReceptionsByPVZParams{ctx, pvzID, startDate, endDate},
		expectationOrigins: ReceptionRepositoryMockGetReceptionsByPVZExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReceptionsByPVZ.expectations = append(mmGetReceptionsByPVZ.expectations, expectation)
	return expectation
}

// Then sets up ReceptionRepository.GetReceptionsByPVZ return parameters for the expectation previously defined by the When method
func (e *ReceptionRepositoryMockGetReceptionsByPVZExpectation) Then(rpa1 []*model.Reception, err error) *ReceptionRepositoryMock {
	e.results = &ReceptionRepositoryMockGetReceptionsByPVZResults{rpa1, err}
	return e.mock
}

// Times sets number of times ReceptionRepository.GetReceptionsByPVZ should be invoked
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) Times(n uint64) *mReceptionRepositoryMockGetReceptionsByPVZ {
	if n == 0 {
		mmGetReceptionsByPVZ.mock.t.Fatalf("Times of ReceptionRepositoryMock.GetReceptionsByPVZ mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReceptionsByPVZ.expectedInvocations, n)
	mmGetReceptionsByPVZ.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReceptionsByPVZ
}

func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) invocationsDone() bool {
	if len(mmGetReceptionsByPVZ.expectations) == 0 && mmGetReceptionsByPVZ.defaultExpectation == nil && mmGetReceptionsByPVZ.mock.funcGetReceptionsByPVZ == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReceptionsByPVZ.mock.afterGetReceptionsByPVZCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReceptionsByPVZ.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReceptionsByPVZ implements mm_repository.ReceptionRepository
func (mmGetReceptionsByPVZ *ReceptionRepositoryMock) GetReceptionsByPVZ(ctx context.Context, pvzID string, startDate *string, endDate *string) (rpa1 []*model.Reception, err error) {
	mm_atomic.AddUint64(&mmGetReceptionsByPVZ.beforeGetReceptionsByPVZCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReceptionsByPVZ.afterGetReceptionsByPVZCounter, 1)

	mmGetReceptionsByPVZ.t.Helper()

	if mmGetReceptionsByPVZ.inspectFuncGetReceptionsByPVZ != nil {
		mmGetReceptionsByPVZ.inspectFuncGetReceptionsByPVZ(ctx, pvzID, startDate, endDate)
	}

	mm_params := ReceptionRepositoryMockGetReceptionsByPVZParams{ctx, pvzID, startDate, endDate}

	// Record call args
	mmGetReceptionsByPVZ.GetReceptionsByPVZMock.mutex.Lock()
	mmGetReceptionsByPVZ.GetReceptionsByPVZMock.callArgs = append(mmGetReceptionsByPVZ.GetReceptionsByPVZMock.callArgs, &mm_params)
	mmGetReceptionsByPVZ.GetReceptionsByPVZMock.mutex.Unlock()

	for _, e := range mmGetReceptionsByPVZ.GetReceptionsByPVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rpa1, e.results.err
		}
	}

	if mmGetReceptionsByPVZ.GetReceptionsByPVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReceptionsByPVZ.GetReceptionsByPVZMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReceptionsByPVZ.GetReceptionsByPVZMock.defaultExpectation.params
		mm_want_ptrs := mmGetReceptionsByPVZ.GetReceptionsByPVZMock.defaultExpectation.paramPtrs

		mm_got := ReceptionRepositoryMockGetReceptionsByPVZParams{ctx, pvzID, startDate, endDate}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReceptionsByPVZ.t.Errorf("ReceptionRepositoryMock.GetReceptionsByPVZ got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReceptionsByPVZ.GetReceptionsByPVZMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzID != nil && !minimock.Equal(*mm_want_ptrs.pvzID, mm_got.pvzID) {
				mmGetReceptionsByPVZ.t.Errorf("ReceptionRepositoryMock.GetReceptionsByPVZ got unexpected parameter pvzID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReceptionsByPVZ.GetReceptionsByPVZMock.defaultExpectation.expectationOrigins.originPvzID, *mm_want_ptrs.pvzID, mm_got.pvzID, minimock.Diff(*mm_want_ptrs.pvzID, mm_got.pvzID))
			}

			if mm_want_ptrs.startDate != nil && !minimock.Equal(*mm_want_ptrs.startDate, mm_got.startDate) {
				mmGetReceptionsByPVZ.t.Errorf("ReceptionRepositoryMock.GetReceptionsByPVZ got unexpected parameter startDate, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReceptionsByPVZ.GetReceptionsByPVZMock.defaultExpectation.expectationOrigins.originStartDate, *mm_want_ptrs.startDate, mm_got.startDate, minimock.Diff(*mm_want_ptrs.startDate, mm_got.startDate))
			}

			if mm_want_ptrs.endDate != nil && !minimock.Equal(*mm_want_ptrs.endDate, mm_got.endDate) {
				mmGetReceptionsByPVZ.t.Errorf("ReceptionRepositoryMock.GetReceptionsByPVZ got unexpected parameter endDate, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReceptionsByPVZ.GetReceptionsByPVZMock.defaultExpectation.expectationOrigins.originEndDate, *mm_want_ptrs.endDate, mm_got.endDate, minimock.Diff(*mm_want_ptrs.endDate, mm_got.endDate))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReceptionsByPVZ.t.Errorf("ReceptionRepositoryMock.GetReceptionsByPVZ got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReceptionsByPVZ.GetReceptionsByPVZMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReceptionsByPVZ.GetReceptionsByPVZMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReceptionsByPVZ.t.Fatal("No results are set for the ReceptionRepositoryMock.GetReceptionsByPVZ")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmGetReceptionsByPVZ.funcGetReceptionsByPVZ != nil {
		return mmGetReceptionsByPVZ.funcGetReceptionsByPVZ(ctx, pvzID, startDate, endDate)
	}
	mmGetReceptionsByPVZ.t.Fatalf("Unexpected call to ReceptionRepositoryMock.GetReceptionsByPVZ. %v %v %v %v", ctx, pvzID, startDate, endDate)
	return
}

// GetReceptionsByPVZAfterCounter returns a count of finished ReceptionRepositoryMock.GetReceptionsByPVZ invocations
func (mmGetReceptionsByPVZ *ReceptionRepositoryMock) GetReceptionsByPVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReceptionsByPVZ.afterGetReceptionsByPVZCounter)
}

// GetReceptionsByPVZBeforeCounter returns a count of ReceptionRepositoryMock.GetReceptionsByPVZ invocations
func (mmGetReceptionsByPVZ *ReceptionRepositoryMock) GetReceptionsByPVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReceptionsByPVZ.beforeGetReceptionsByPVZCounter)
}

// Calls returns a list of arguments used in each call to ReceptionRepositoryMock.GetReceptionsByPVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReceptionsByPVZ *mReceptionRepositoryMockGetReceptionsByPVZ) Calls() []*ReceptionRepositoryMockGetReceptionsByPVZParams {
	mmGetReceptionsByPVZ.mutex.RLock()

	argCopy := make([]*ReceptionRepositoryMockGetReceptionsByPVZParams, len(mmGetReceptionsByPVZ.callArgs))
	copy(argCopy, mmGetReceptionsByPVZ.callArgs)

	mmGetReceptionsByPVZ.mutex.RUnlock()

	return argCopy
}

// MinimockGetReceptionsByPVZDone returns true if the count of the GetReceptionsByPVZ invocations corresponds
// the number of defined expectations
func (m *ReceptionRepositoryMock) MinimockGetReceptionsByPVZDone() bool {
	if m.GetReceptionsByPVZMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReceptionsByPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReceptionsByPVZMock.invocationsDone()
}

// MinimockGetReceptionsByPVZInspect logs each unmet expectation
func (m *ReceptionRepositoryMock) MinimockGetReceptionsByPVZInspect() {
	for _, e := range m.GetReceptionsByPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.GetReceptionsByPVZ at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReceptionsByPVZCounter := mm_atomic.LoadUint64(&m.afterGetReceptionsByPVZCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReceptionsByPVZMock.defaultExpectation != nil && afterGetReceptionsByPVZCounter < 1 {
		if m.GetReceptionsByPVZMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.GetReceptionsByPVZ at\n%s", m.GetReceptionsByPVZMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionRepositoryMock.GetReceptionsByPVZ at\n%s with params: %#v", m.GetReceptionsByPVZMock.defaultExpectation.expectationOrigins.origin, *m.GetReceptionsByPVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReceptionsByPVZ != nil && afterGetReceptionsByPVZCounter < 1 {
		m.t.Errorf("Expected call to ReceptionRepositoryMock.GetReceptionsByPVZ at\n%s", m.funcGetReceptionsByPVZOrigin)
	}

	if !m.GetReceptionsByPVZMock.invocationsDone() && afterGetReceptionsByPVZCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionRepositoryMock.GetReceptionsByPVZ at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReceptionsByPVZMock.expectedInvocations), m.GetReceptionsByPVZMock.expectedInvocationsOrigin, afterGetReceptionsByPVZCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReceptionRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddProductInspect()

			m.MinimockCloseReceptionInspect()

			m.MinimockCreateInspect()

			m.MinimockDeleteLastProductByPVZInspect()

			m.MinimockGetOpenReceptionForPVZInspect()

			m.MinimockGetProductsByReceptionInspect()

			m.MinimockGetReceptionsByPVZInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReceptionRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReceptionRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddProductDone() &&
		m.MinimockCloseReceptionDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteLastProductByPVZDone() &&
		m.MinimockGetOpenReceptionForPVZDone() &&
		m.MinimockGetProductsByReceptionDone() &&
		m.MinimockGetReceptionsByPVZDone()
}
