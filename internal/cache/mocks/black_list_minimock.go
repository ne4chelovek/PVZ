// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i PVZ/internal/cache.BlackList -o black_list_minimock.go -n BlackListMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// BlackListMock implements mm_cache.BlackList
type BlackListMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddToBlacklist          func(token string, expiration time.Duration) (err error)
	funcAddToBlacklistOrigin    string
	inspectFuncAddToBlacklist   func(token string, expiration time.Duration)
	afterAddToBlacklistCounter  uint64
	beforeAddToBlacklistCounter uint64
	AddToBlacklistMock          mBlackListMockAddToBlacklist

	funcGet          func(ctx context.Context, token string) (s1 string, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, token string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mBlackListMockGet

	funcIsTokenBlacklisted          func(token string) (b1 bool, err error)
	funcIsTokenBlacklistedOrigin    string
	inspectFuncIsTokenBlacklisted   func(token string)
	afterIsTokenBlacklistedCounter  uint64
	beforeIsTokenBlacklistedCounter uint64
	IsTokenBlacklistedMock          mBlackListMockIsTokenBlacklisted
}

// NewBlackListMock returns a mock for mm_cache.BlackList
func NewBlackListMock(t minimock.Tester) *BlackListMock {
	m := &BlackListMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToBlacklistMock = mBlackListMockAddToBlacklist{mock: m}
	m.AddToBlacklistMock.callArgs = []*BlackListMockAddToBlacklistParams{}

	m.GetMock = mBlackListMockGet{mock: m}
	m.GetMock.callArgs = []*BlackListMockGetParams{}

	m.IsTokenBlacklistedMock = mBlackListMockIsTokenBlacklisted{mock: m}
	m.IsTokenBlacklistedMock.callArgs = []*BlackListMockIsTokenBlacklistedParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBlackListMockAddToBlacklist struct {
	optional           bool
	mock               *BlackListMock
	defaultExpectation *BlackListMockAddToBlacklistExpectation
	expectations       []*BlackListMockAddToBlacklistExpectation

	callArgs []*BlackListMockAddToBlacklistParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BlackListMockAddToBlacklistExpectation specifies expectation struct of the BlackList.AddToBlacklist
type BlackListMockAddToBlacklistExpectation struct {
	mock               *BlackListMock
	params             *BlackListMockAddToBlacklistParams
	paramPtrs          *BlackListMockAddToBlacklistParamPtrs
	expectationOrigins BlackListMockAddToBlacklistExpectationOrigins
	results            *BlackListMockAddToBlacklistResults
	returnOrigin       string
	Counter            uint64
}

// BlackListMockAddToBlacklistParams contains parameters of the BlackList.AddToBlacklist
type BlackListMockAddToBlacklistParams struct {
	token      string
	expiration time.Duration
}

// BlackListMockAddToBlacklistParamPtrs contains pointers to parameters of the BlackList.AddToBlacklist
type BlackListMockAddToBlacklistParamPtrs struct {
	token      *string
	expiration *time.Duration
}

// BlackListMockAddToBlacklistResults contains results of the BlackList.AddToBlacklist
type BlackListMockAddToBlacklistResults struct {
	err error
}

// BlackListMockAddToBlacklistOrigins contains origins of expectations of the BlackList.AddToBlacklist
type BlackListMockAddToBlacklistExpectationOrigins struct {
	origin           string
	originToken      string
	originExpiration string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddToBlacklist *mBlackListMockAddToBlacklist) Optional() *mBlackListMockAddToBlacklist {
	mmAddToBlacklist.optional = true
	return mmAddToBlacklist
}

// Expect sets up expected params for BlackList.AddToBlacklist
func (mmAddToBlacklist *mBlackListMockAddToBlacklist) Expect(token string, expiration time.Duration) *mBlackListMockAddToBlacklist {
	if mmAddToBlacklist.mock.funcAddToBlacklist != nil {
		mmAddToBlacklist.mock.t.Fatalf("BlackListMock.AddToBlacklist mock is already set by Set")
	}

	if mmAddToBlacklist.defaultExpectation == nil {
		mmAddToBlacklist.defaultExpectation = &BlackListMockAddToBlacklistExpectation{}
	}

	if mmAddToBlacklist.defaultExpectation.paramPtrs != nil {
		mmAddToBlacklist.mock.t.Fatalf("BlackListMock.AddToBlacklist mock is already set by ExpectParams functions")
	}

	mmAddToBlacklist.defaultExpectation.params = &BlackListMockAddToBlacklistParams{token, expiration}
	mmAddToBlacklist.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddToBlacklist.expectations {
		if minimock.Equal(e.params, mmAddToBlacklist.defaultExpectation.params) {
			mmAddToBlacklist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToBlacklist.defaultExpectation.params)
		}
	}

	return mmAddToBlacklist
}

// ExpectTokenParam1 sets up expected param token for BlackList.AddToBlacklist
func (mmAddToBlacklist *mBlackListMockAddToBlacklist) ExpectTokenParam1(token string) *mBlackListMockAddToBlacklist {
	if mmAddToBlacklist.mock.funcAddToBlacklist != nil {
		mmAddToBlacklist.mock.t.Fatalf("BlackListMock.AddToBlacklist mock is already set by Set")
	}

	if mmAddToBlacklist.defaultExpectation == nil {
		mmAddToBlacklist.defaultExpectation = &BlackListMockAddToBlacklistExpectation{}
	}

	if mmAddToBlacklist.defaultExpectation.params != nil {
		mmAddToBlacklist.mock.t.Fatalf("BlackListMock.AddToBlacklist mock is already set by Expect")
	}

	if mmAddToBlacklist.defaultExpectation.paramPtrs == nil {
		mmAddToBlacklist.defaultExpectation.paramPtrs = &BlackListMockAddToBlacklistParamPtrs{}
	}
	mmAddToBlacklist.defaultExpectation.paramPtrs.token = &token
	mmAddToBlacklist.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmAddToBlacklist
}

// ExpectExpirationParam2 sets up expected param expiration for BlackList.AddToBlacklist
func (mmAddToBlacklist *mBlackListMockAddToBlacklist) ExpectExpirationParam2(expiration time.Duration) *mBlackListMockAddToBlacklist {
	if mmAddToBlacklist.mock.funcAddToBlacklist != nil {
		mmAddToBlacklist.mock.t.Fatalf("BlackListMock.AddToBlacklist mock is already set by Set")
	}

	if mmAddToBlacklist.defaultExpectation == nil {
		mmAddToBlacklist.defaultExpectation = &BlackListMockAddToBlacklistExpectation{}
	}

	if mmAddToBlacklist.defaultExpectation.params != nil {
		mmAddToBlacklist.mock.t.Fatalf("BlackListMock.AddToBlacklist mock is already set by Expect")
	}

	if mmAddToBlacklist.defaultExpectation.paramPtrs == nil {
		mmAddToBlacklist.defaultExpectation.paramPtrs = &BlackListMockAddToBlacklistParamPtrs{}
	}
	mmAddToBlacklist.defaultExpectation.paramPtrs.expiration = &expiration
	mmAddToBlacklist.defaultExpectation.expectationOrigins.originExpiration = minimock.CallerInfo(1)

	return mmAddToBlacklist
}

// Inspect accepts an inspector function that has same arguments as the BlackList.AddToBlacklist
func (mmAddToBlacklist *mBlackListMockAddToBlacklist) Inspect(f func(token string, expiration time.Duration)) *mBlackListMockAddToBlacklist {
	if mmAddToBlacklist.mock.inspectFuncAddToBlacklist != nil {
		mmAddToBlacklist.mock.t.Fatalf("Inspect function is already set for BlackListMock.AddToBlacklist")
	}

	mmAddToBlacklist.mock.inspectFuncAddToBlacklist = f

	return mmAddToBlacklist
}

// Return sets up results that will be returned by BlackList.AddToBlacklist
func (mmAddToBlacklist *mBlackListMockAddToBlacklist) Return(err error) *BlackListMock {
	if mmAddToBlacklist.mock.funcAddToBlacklist != nil {
		mmAddToBlacklist.mock.t.Fatalf("BlackListMock.AddToBlacklist mock is already set by Set")
	}

	if mmAddToBlacklist.defaultExpectation == nil {
		mmAddToBlacklist.defaultExpectation = &BlackListMockAddToBlacklistExpectation{mock: mmAddToBlacklist.mock}
	}
	mmAddToBlacklist.defaultExpectation.results = &BlackListMockAddToBlacklistResults{err}
	mmAddToBlacklist.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddToBlacklist.mock
}

// Set uses given function f to mock the BlackList.AddToBlacklist method
func (mmAddToBlacklist *mBlackListMockAddToBlacklist) Set(f func(token string, expiration time.Duration) (err error)) *BlackListMock {
	if mmAddToBlacklist.defaultExpectation != nil {
		mmAddToBlacklist.mock.t.Fatalf("Default expectation is already set for the BlackList.AddToBlacklist method")
	}

	if len(mmAddToBlacklist.expectations) > 0 {
		mmAddToBlacklist.mock.t.Fatalf("Some expectations are already set for the BlackList.AddToBlacklist method")
	}

	mmAddToBlacklist.mock.funcAddToBlacklist = f
	mmAddToBlacklist.mock.funcAddToBlacklistOrigin = minimock.CallerInfo(1)
	return mmAddToBlacklist.mock
}

// When sets expectation for the BlackList.AddToBlacklist which will trigger the result defined by the following
// Then helper
func (mmAddToBlacklist *mBlackListMockAddToBlacklist) When(token string, expiration time.Duration) *BlackListMockAddToBlacklistExpectation {
	if mmAddToBlacklist.mock.funcAddToBlacklist != nil {
		mmAddToBlacklist.mock.t.Fatalf("BlackListMock.AddToBlacklist mock is already set by Set")
	}

	expectation := &BlackListMockAddToBlacklistExpectation{
		mock:               mmAddToBlacklist.mock,
		params:             &BlackListMockAddToBlacklistParams{token, expiration},
		expectationOrigins: BlackListMockAddToBlacklistExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddToBlacklist.expectations = append(mmAddToBlacklist.expectations, expectation)
	return expectation
}

// Then sets up BlackList.AddToBlacklist return parameters for the expectation previously defined by the When method
func (e *BlackListMockAddToBlacklistExpectation) Then(err error) *BlackListMock {
	e.results = &BlackListMockAddToBlacklistResults{err}
	return e.mock
}

// Times sets number of times BlackList.AddToBlacklist should be invoked
func (mmAddToBlacklist *mBlackListMockAddToBlacklist) Times(n uint64) *mBlackListMockAddToBlacklist {
	if n == 0 {
		mmAddToBlacklist.mock.t.Fatalf("Times of BlackListMock.AddToBlacklist mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddToBlacklist.expectedInvocations, n)
	mmAddToBlacklist.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddToBlacklist
}

func (mmAddToBlacklist *mBlackListMockAddToBlacklist) invocationsDone() bool {
	if len(mmAddToBlacklist.expectations) == 0 && mmAddToBlacklist.defaultExpectation == nil && mmAddToBlacklist.mock.funcAddToBlacklist == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddToBlacklist.mock.afterAddToBlacklistCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddToBlacklist.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddToBlacklist implements mm_cache.BlackList
func (mmAddToBlacklist *BlackListMock) AddToBlacklist(token string, expiration time.Duration) (err error) {
	mm_atomic.AddUint64(&mmAddToBlacklist.beforeAddToBlacklistCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToBlacklist.afterAddToBlacklistCounter, 1)

	mmAddToBlacklist.t.Helper()

	if mmAddToBlacklist.inspectFuncAddToBlacklist != nil {
		mmAddToBlacklist.inspectFuncAddToBlacklist(token, expiration)
	}

	mm_params := BlackListMockAddToBlacklistParams{token, expiration}

	// Record call args
	mmAddToBlacklist.AddToBlacklistMock.mutex.Lock()
	mmAddToBlacklist.AddToBlacklistMock.callArgs = append(mmAddToBlacklist.AddToBlacklistMock.callArgs, &mm_params)
	mmAddToBlacklist.AddToBlacklistMock.mutex.Unlock()

	for _, e := range mmAddToBlacklist.AddToBlacklistMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToBlacklist.AddToBlacklistMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToBlacklist.AddToBlacklistMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToBlacklist.AddToBlacklistMock.defaultExpectation.params
		mm_want_ptrs := mmAddToBlacklist.AddToBlacklistMock.defaultExpectation.paramPtrs

		mm_got := BlackListMockAddToBlacklistParams{token, expiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmAddToBlacklist.t.Errorf("BlackListMock.AddToBlacklist got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToBlacklist.AddToBlacklistMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

			if mm_want_ptrs.expiration != nil && !minimock.Equal(*mm_want_ptrs.expiration, mm_got.expiration) {
				mmAddToBlacklist.t.Errorf("BlackListMock.AddToBlacklist got unexpected parameter expiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToBlacklist.AddToBlacklistMock.defaultExpectation.expectationOrigins.originExpiration, *mm_want_ptrs.expiration, mm_got.expiration, minimock.Diff(*mm_want_ptrs.expiration, mm_got.expiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToBlacklist.t.Errorf("BlackListMock.AddToBlacklist got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddToBlacklist.AddToBlacklistMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToBlacklist.AddToBlacklistMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToBlacklist.t.Fatal("No results are set for the BlackListMock.AddToBlacklist")
		}
		return (*mm_results).err
	}
	if mmAddToBlacklist.funcAddToBlacklist != nil {
		return mmAddToBlacklist.funcAddToBlacklist(token, expiration)
	}
	mmAddToBlacklist.t.Fatalf("Unexpected call to BlackListMock.AddToBlacklist. %v %v", token, expiration)
	return
}

// AddToBlacklistAfterCounter returns a count of finished BlackListMock.AddToBlacklist invocations
func (mmAddToBlacklist *BlackListMock) AddToBlacklistAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToBlacklist.afterAddToBlacklistCounter)
}

// AddToBlacklistBeforeCounter returns a count of BlackListMock.AddToBlacklist invocations
func (mmAddToBlacklist *BlackListMock) AddToBlacklistBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToBlacklist.beforeAddToBlacklistCounter)
}

// Calls returns a list of arguments used in each call to BlackListMock.AddToBlacklist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToBlacklist *mBlackListMockAddToBlacklist) Calls() []*BlackListMockAddToBlacklistParams {
	mmAddToBlacklist.mutex.RLock()

	argCopy := make([]*BlackListMockAddToBlacklistParams, len(mmAddToBlacklist.callArgs))
	copy(argCopy, mmAddToBlacklist.callArgs)

	mmAddToBlacklist.mutex.RUnlock()

	return argCopy
}

// MinimockAddToBlacklistDone returns true if the count of the AddToBlacklist invocations corresponds
// the number of defined expectations
func (m *BlackListMock) MinimockAddToBlacklistDone() bool {
	if m.AddToBlacklistMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddToBlacklistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddToBlacklistMock.invocationsDone()
}

// MinimockAddToBlacklistInspect logs each unmet expectation
func (m *BlackListMock) MinimockAddToBlacklistInspect() {
	for _, e := range m.AddToBlacklistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BlackListMock.AddToBlacklist at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddToBlacklistCounter := mm_atomic.LoadUint64(&m.afterAddToBlacklistCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddToBlacklistMock.defaultExpectation != nil && afterAddToBlacklistCounter < 1 {
		if m.AddToBlacklistMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BlackListMock.AddToBlacklist at\n%s", m.AddToBlacklistMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BlackListMock.AddToBlacklist at\n%s with params: %#v", m.AddToBlacklistMock.defaultExpectation.expectationOrigins.origin, *m.AddToBlacklistMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToBlacklist != nil && afterAddToBlacklistCounter < 1 {
		m.t.Errorf("Expected call to BlackListMock.AddToBlacklist at\n%s", m.funcAddToBlacklistOrigin)
	}

	if !m.AddToBlacklistMock.invocationsDone() && afterAddToBlacklistCounter > 0 {
		m.t.Errorf("Expected %d calls to BlackListMock.AddToBlacklist at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddToBlacklistMock.expectedInvocations), m.AddToBlacklistMock.expectedInvocationsOrigin, afterAddToBlacklistCounter)
	}
}

type mBlackListMockGet struct {
	optional           bool
	mock               *BlackListMock
	defaultExpectation *BlackListMockGetExpectation
	expectations       []*BlackListMockGetExpectation

	callArgs []*BlackListMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BlackListMockGetExpectation specifies expectation struct of the BlackList.Get
type BlackListMockGetExpectation struct {
	mock               *BlackListMock
	params             *BlackListMockGetParams
	paramPtrs          *BlackListMockGetParamPtrs
	expectationOrigins BlackListMockGetExpectationOrigins
	results            *BlackListMockGetResults
	returnOrigin       string
	Counter            uint64
}

// BlackListMockGetParams contains parameters of the BlackList.Get
type BlackListMockGetParams struct {
	ctx   context.Context
	token string
}

// BlackListMockGetParamPtrs contains pointers to parameters of the BlackList.Get
type BlackListMockGetParamPtrs struct {
	ctx   *context.Context
	token *string
}

// BlackListMockGetResults contains results of the BlackList.Get
type BlackListMockGetResults struct {
	s1  string
	err error
}

// BlackListMockGetOrigins contains origins of expectations of the BlackList.Get
type BlackListMockGetExpectationOrigins struct {
	origin      string
	originCtx   string
	originToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mBlackListMockGet) Optional() *mBlackListMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for BlackList.Get
func (mmGet *mBlackListMockGet) Expect(ctx context.Context, token string) *mBlackListMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("BlackListMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &BlackListMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("BlackListMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &BlackListMockGetParams{ctx, token}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for BlackList.Get
func (mmGet *mBlackListMockGet) ExpectCtxParam1(ctx context.Context) *mBlackListMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("BlackListMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &BlackListMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("BlackListMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &BlackListMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectTokenParam2 sets up expected param token for BlackList.Get
func (mmGet *mBlackListMockGet) ExpectTokenParam2(token string) *mBlackListMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("BlackListMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &BlackListMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("BlackListMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &BlackListMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.token = &token
	mmGet.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the BlackList.Get
func (mmGet *mBlackListMockGet) Inspect(f func(ctx context.Context, token string)) *mBlackListMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for BlackListMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by BlackList.Get
func (mmGet *mBlackListMockGet) Return(s1 string, err error) *BlackListMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("BlackListMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &BlackListMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &BlackListMockGetResults{s1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the BlackList.Get method
func (mmGet *mBlackListMockGet) Set(f func(ctx context.Context, token string) (s1 string, err error)) *BlackListMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the BlackList.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the BlackList.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the BlackList.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mBlackListMockGet) When(ctx context.Context, token string) *BlackListMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("BlackListMock.Get mock is already set by Set")
	}

	expectation := &BlackListMockGetExpectation{
		mock:               mmGet.mock,
		params:             &BlackListMockGetParams{ctx, token},
		expectationOrigins: BlackListMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up BlackList.Get return parameters for the expectation previously defined by the When method
func (e *BlackListMockGetExpectation) Then(s1 string, err error) *BlackListMock {
	e.results = &BlackListMockGetResults{s1, err}
	return e.mock
}

// Times sets number of times BlackList.Get should be invoked
func (mmGet *mBlackListMockGet) Times(n uint64) *mBlackListMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of BlackListMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mBlackListMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_cache.BlackList
func (mmGet *BlackListMock) Get(ctx context.Context, token string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, token)
	}

	mm_params := BlackListMockGetParams{ctx, token}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := BlackListMockGetParams{ctx, token}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("BlackListMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmGet.t.Errorf("BlackListMock.Get got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("BlackListMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the BlackListMock.Get")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, token)
	}
	mmGet.t.Fatalf("Unexpected call to BlackListMock.Get. %v %v", ctx, token)
	return
}

// GetAfterCounter returns a count of finished BlackListMock.Get invocations
func (mmGet *BlackListMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of BlackListMock.Get invocations
func (mmGet *BlackListMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to BlackListMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mBlackListMockGet) Calls() []*BlackListMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*BlackListMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *BlackListMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *BlackListMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BlackListMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BlackListMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BlackListMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to BlackListMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to BlackListMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mBlackListMockIsTokenBlacklisted struct {
	optional           bool
	mock               *BlackListMock
	defaultExpectation *BlackListMockIsTokenBlacklistedExpectation
	expectations       []*BlackListMockIsTokenBlacklistedExpectation

	callArgs []*BlackListMockIsTokenBlacklistedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BlackListMockIsTokenBlacklistedExpectation specifies expectation struct of the BlackList.IsTokenBlacklisted
type BlackListMockIsTokenBlacklistedExpectation struct {
	mock               *BlackListMock
	params             *BlackListMockIsTokenBlacklistedParams
	paramPtrs          *BlackListMockIsTokenBlacklistedParamPtrs
	expectationOrigins BlackListMockIsTokenBlacklistedExpectationOrigins
	results            *BlackListMockIsTokenBlacklistedResults
	returnOrigin       string
	Counter            uint64
}

// BlackListMockIsTokenBlacklistedParams contains parameters of the BlackList.IsTokenBlacklisted
type BlackListMockIsTokenBlacklistedParams struct {
	token string
}

// BlackListMockIsTokenBlacklistedParamPtrs contains pointers to parameters of the BlackList.IsTokenBlacklisted
type BlackListMockIsTokenBlacklistedParamPtrs struct {
	token *string
}

// BlackListMockIsTokenBlacklistedResults contains results of the BlackList.IsTokenBlacklisted
type BlackListMockIsTokenBlacklistedResults struct {
	b1  bool
	err error
}

// BlackListMockIsTokenBlacklistedOrigins contains origins of expectations of the BlackList.IsTokenBlacklisted
type BlackListMockIsTokenBlacklistedExpectationOrigins struct {
	origin      string
	originToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsTokenBlacklisted *mBlackListMockIsTokenBlacklisted) Optional() *mBlackListMockIsTokenBlacklisted {
	mmIsTokenBlacklisted.optional = true
	return mmIsTokenBlacklisted
}

// Expect sets up expected params for BlackList.IsTokenBlacklisted
func (mmIsTokenBlacklisted *mBlackListMockIsTokenBlacklisted) Expect(token string) *mBlackListMockIsTokenBlacklisted {
	if mmIsTokenBlacklisted.mock.funcIsTokenBlacklisted != nil {
		mmIsTokenBlacklisted.mock.t.Fatalf("BlackListMock.IsTokenBlacklisted mock is already set by Set")
	}

	if mmIsTokenBlacklisted.defaultExpectation == nil {
		mmIsTokenBlacklisted.defaultExpectation = &BlackListMockIsTokenBlacklistedExpectation{}
	}

	if mmIsTokenBlacklisted.defaultExpectation.paramPtrs != nil {
		mmIsTokenBlacklisted.mock.t.Fatalf("BlackListMock.IsTokenBlacklisted mock is already set by ExpectParams functions")
	}

	mmIsTokenBlacklisted.defaultExpectation.params = &BlackListMockIsTokenBlacklistedParams{token}
	mmIsTokenBlacklisted.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsTokenBlacklisted.expectations {
		if minimock.Equal(e.params, mmIsTokenBlacklisted.defaultExpectation.params) {
			mmIsTokenBlacklisted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsTokenBlacklisted.defaultExpectation.params)
		}
	}

	return mmIsTokenBlacklisted
}

// ExpectTokenParam1 sets up expected param token for BlackList.IsTokenBlacklisted
func (mmIsTokenBlacklisted *mBlackListMockIsTokenBlacklisted) ExpectTokenParam1(token string) *mBlackListMockIsTokenBlacklisted {
	if mmIsTokenBlacklisted.mock.funcIsTokenBlacklisted != nil {
		mmIsTokenBlacklisted.mock.t.Fatalf("BlackListMock.IsTokenBlacklisted mock is already set by Set")
	}

	if mmIsTokenBlacklisted.defaultExpectation == nil {
		mmIsTokenBlacklisted.defaultExpectation = &BlackListMockIsTokenBlacklistedExpectation{}
	}

	if mmIsTokenBlacklisted.defaultExpectation.params != nil {
		mmIsTokenBlacklisted.mock.t.Fatalf("BlackListMock.IsTokenBlacklisted mock is already set by Expect")
	}

	if mmIsTokenBlacklisted.defaultExpectation.paramPtrs == nil {
		mmIsTokenBlacklisted.defaultExpectation.paramPtrs = &BlackListMockIsTokenBlacklistedParamPtrs{}
	}
	mmIsTokenBlacklisted.defaultExpectation.paramPtrs.token = &token
	mmIsTokenBlacklisted.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmIsTokenBlacklisted
}

// Inspect accepts an inspector function that has same arguments as the BlackList.IsTokenBlacklisted
func (mmIsTokenBlacklisted *mBlackListMockIsTokenBlacklisted) Inspect(f func(token string)) *mBlackListMockIsTokenBlacklisted {
	if mmIsTokenBlacklisted.mock.inspectFuncIsTokenBlacklisted != nil {
		mmIsTokenBlacklisted.mock.t.Fatalf("Inspect function is already set for BlackListMock.IsTokenBlacklisted")
	}

	mmIsTokenBlacklisted.mock.inspectFuncIsTokenBlacklisted = f

	return mmIsTokenBlacklisted
}

// Return sets up results that will be returned by BlackList.IsTokenBlacklisted
func (mmIsTokenBlacklisted *mBlackListMockIsTokenBlacklisted) Return(b1 bool, err error) *BlackListMock {
	if mmIsTokenBlacklisted.mock.funcIsTokenBlacklisted != nil {
		mmIsTokenBlacklisted.mock.t.Fatalf("BlackListMock.IsTokenBlacklisted mock is already set by Set")
	}

	if mmIsTokenBlacklisted.defaultExpectation == nil {
		mmIsTokenBlacklisted.defaultExpectation = &BlackListMockIsTokenBlacklistedExpectation{mock: mmIsTokenBlacklisted.mock}
	}
	mmIsTokenBlacklisted.defaultExpectation.results = &BlackListMockIsTokenBlacklistedResults{b1, err}
	mmIsTokenBlacklisted.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsTokenBlacklisted.mock
}

// Set uses given function f to mock the BlackList.IsTokenBlacklisted method
func (mmIsTokenBlacklisted *mBlackListMockIsTokenBlacklisted) Set(f func(token string) (b1 bool, err error)) *BlackListMock {
	if mmIsTokenBlacklisted.defaultExpectation != nil {
		mmIsTokenBlacklisted.mock.t.Fatalf("Default expectation is already set for the BlackList.IsTokenBlacklisted method")
	}

	if len(mmIsTokenBlacklisted.expectations) > 0 {
		mmIsTokenBlacklisted.mock.t.Fatalf("Some expectations are already set for the BlackList.IsTokenBlacklisted method")
	}

	mmIsTokenBlacklisted.mock.funcIsTokenBlacklisted = f
	mmIsTokenBlacklisted.mock.funcIsTokenBlacklistedOrigin = minimock.CallerInfo(1)
	return mmIsTokenBlacklisted.mock
}

// When sets expectation for the BlackList.IsTokenBlacklisted which will trigger the result defined by the following
// Then helper
func (mmIsTokenBlacklisted *mBlackListMockIsTokenBlacklisted) When(token string) *BlackListMockIsTokenBlacklistedExpectation {
	if mmIsTokenBlacklisted.mock.funcIsTokenBlacklisted != nil {
		mmIsTokenBlacklisted.mock.t.Fatalf("BlackListMock.IsTokenBlacklisted mock is already set by Set")
	}

	expectation := &BlackListMockIsTokenBlacklistedExpectation{
		mock:               mmIsTokenBlacklisted.mock,
		params:             &BlackListMockIsTokenBlacklistedParams{token},
		expectationOrigins: BlackListMockIsTokenBlacklistedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsTokenBlacklisted.expectations = append(mmIsTokenBlacklisted.expectations, expectation)
	return expectation
}

// Then sets up BlackList.IsTokenBlacklisted return parameters for the expectation previously defined by the When method
func (e *BlackListMockIsTokenBlacklistedExpectation) Then(b1 bool, err error) *BlackListMock {
	e.results = &BlackListMockIsTokenBlacklistedResults{b1, err}
	return e.mock
}

// Times sets number of times BlackList.IsTokenBlacklisted should be invoked
func (mmIsTokenBlacklisted *mBlackListMockIsTokenBlacklisted) Times(n uint64) *mBlackListMockIsTokenBlacklisted {
	if n == 0 {
		mmIsTokenBlacklisted.mock.t.Fatalf("Times of BlackListMock.IsTokenBlacklisted mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsTokenBlacklisted.expectedInvocations, n)
	mmIsTokenBlacklisted.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsTokenBlacklisted
}

func (mmIsTokenBlacklisted *mBlackListMockIsTokenBlacklisted) invocationsDone() bool {
	if len(mmIsTokenBlacklisted.expectations) == 0 && mmIsTokenBlacklisted.defaultExpectation == nil && mmIsTokenBlacklisted.mock.funcIsTokenBlacklisted == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsTokenBlacklisted.mock.afterIsTokenBlacklistedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsTokenBlacklisted.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsTokenBlacklisted implements mm_cache.BlackList
func (mmIsTokenBlacklisted *BlackListMock) IsTokenBlacklisted(token string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsTokenBlacklisted.beforeIsTokenBlacklistedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsTokenBlacklisted.afterIsTokenBlacklistedCounter, 1)

	mmIsTokenBlacklisted.t.Helper()

	if mmIsTokenBlacklisted.inspectFuncIsTokenBlacklisted != nil {
		mmIsTokenBlacklisted.inspectFuncIsTokenBlacklisted(token)
	}

	mm_params := BlackListMockIsTokenBlacklistedParams{token}

	// Record call args
	mmIsTokenBlacklisted.IsTokenBlacklistedMock.mutex.Lock()
	mmIsTokenBlacklisted.IsTokenBlacklistedMock.callArgs = append(mmIsTokenBlacklisted.IsTokenBlacklistedMock.callArgs, &mm_params)
	mmIsTokenBlacklisted.IsTokenBlacklistedMock.mutex.Unlock()

	for _, e := range mmIsTokenBlacklisted.IsTokenBlacklistedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsTokenBlacklisted.IsTokenBlacklistedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsTokenBlacklisted.IsTokenBlacklistedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsTokenBlacklisted.IsTokenBlacklistedMock.defaultExpectation.params
		mm_want_ptrs := mmIsTokenBlacklisted.IsTokenBlacklistedMock.defaultExpectation.paramPtrs

		mm_got := BlackListMockIsTokenBlacklistedParams{token}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmIsTokenBlacklisted.t.Errorf("BlackListMock.IsTokenBlacklisted got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsTokenBlacklisted.IsTokenBlacklistedMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsTokenBlacklisted.t.Errorf("BlackListMock.IsTokenBlacklisted got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsTokenBlacklisted.IsTokenBlacklistedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsTokenBlacklisted.IsTokenBlacklistedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsTokenBlacklisted.t.Fatal("No results are set for the BlackListMock.IsTokenBlacklisted")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsTokenBlacklisted.funcIsTokenBlacklisted != nil {
		return mmIsTokenBlacklisted.funcIsTokenBlacklisted(token)
	}
	mmIsTokenBlacklisted.t.Fatalf("Unexpected call to BlackListMock.IsTokenBlacklisted. %v", token)
	return
}

// IsTokenBlacklistedAfterCounter returns a count of finished BlackListMock.IsTokenBlacklisted invocations
func (mmIsTokenBlacklisted *BlackListMock) IsTokenBlacklistedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsTokenBlacklisted.afterIsTokenBlacklistedCounter)
}

// IsTokenBlacklistedBeforeCounter returns a count of BlackListMock.IsTokenBlacklisted invocations
func (mmIsTokenBlacklisted *BlackListMock) IsTokenBlacklistedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsTokenBlacklisted.beforeIsTokenBlacklistedCounter)
}

// Calls returns a list of arguments used in each call to BlackListMock.IsTokenBlacklisted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsTokenBlacklisted *mBlackListMockIsTokenBlacklisted) Calls() []*BlackListMockIsTokenBlacklistedParams {
	mmIsTokenBlacklisted.mutex.RLock()

	argCopy := make([]*BlackListMockIsTokenBlacklistedParams, len(mmIsTokenBlacklisted.callArgs))
	copy(argCopy, mmIsTokenBlacklisted.callArgs)

	mmIsTokenBlacklisted.mutex.RUnlock()

	return argCopy
}

// MinimockIsTokenBlacklistedDone returns true if the count of the IsTokenBlacklisted invocations corresponds
// the number of defined expectations
func (m *BlackListMock) MinimockIsTokenBlacklistedDone() bool {
	if m.IsTokenBlacklistedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsTokenBlacklistedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsTokenBlacklistedMock.invocationsDone()
}

// MinimockIsTokenBlacklistedInspect logs each unmet expectation
func (m *BlackListMock) MinimockIsTokenBlacklistedInspect() {
	for _, e := range m.IsTokenBlacklistedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BlackListMock.IsTokenBlacklisted at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsTokenBlacklistedCounter := mm_atomic.LoadUint64(&m.afterIsTokenBlacklistedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsTokenBlacklistedMock.defaultExpectation != nil && afterIsTokenBlacklistedCounter < 1 {
		if m.IsTokenBlacklistedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BlackListMock.IsTokenBlacklisted at\n%s", m.IsTokenBlacklistedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BlackListMock.IsTokenBlacklisted at\n%s with params: %#v", m.IsTokenBlacklistedMock.defaultExpectation.expectationOrigins.origin, *m.IsTokenBlacklistedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsTokenBlacklisted != nil && afterIsTokenBlacklistedCounter < 1 {
		m.t.Errorf("Expected call to BlackListMock.IsTokenBlacklisted at\n%s", m.funcIsTokenBlacklistedOrigin)
	}

	if !m.IsTokenBlacklistedMock.invocationsDone() && afterIsTokenBlacklistedCounter > 0 {
		m.t.Errorf("Expected %d calls to BlackListMock.IsTokenBlacklisted at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsTokenBlacklistedMock.expectedInvocations), m.IsTokenBlacklistedMock.expectedInvocationsOrigin, afterIsTokenBlacklistedCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BlackListMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddToBlacklistInspect()

			m.MinimockGetInspect()

			m.MinimockIsTokenBlacklistedInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BlackListMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BlackListMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToBlacklistDone() &&
		m.MinimockGetDone() &&
		m.MinimockIsTokenBlacklistedDone()
}
