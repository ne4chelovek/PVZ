// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i PVZ/internal/service.AuthService -o auth_service_minimock.go -n AuthServiceMock -p mocks

import (
	"PVZ/internal/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AuthServiceMock implements mm_service.AuthService
type AuthServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcLogin          func(ctx context.Context, email string, password string) (s1 string, err error)
	funcLoginOrigin    string
	inspectFuncLogin   func(ctx context.Context, email string, password string)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mAuthServiceMockLogin

	funcLoginDummy          func(ctx context.Context, role string) (s1 string, err error)
	funcLoginDummyOrigin    string
	inspectFuncLoginDummy   func(ctx context.Context, role string)
	afterLoginDummyCounter  uint64
	beforeLoginDummyCounter uint64
	LoginDummyMock          mAuthServiceMockLoginDummy

	funcRegister          func(ctx context.Context, email string, password string, role string) (up1 *model.User, err error)
	funcRegisterOrigin    string
	inspectFuncRegister   func(ctx context.Context, email string, password string, role string)
	afterRegisterCounter  uint64
	beforeRegisterCounter uint64
	RegisterMock          mAuthServiceMockRegister
}

// NewAuthServiceMock returns a mock for mm_service.AuthService
func NewAuthServiceMock(t minimock.Tester) *AuthServiceMock {
	m := &AuthServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.LoginMock = mAuthServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*AuthServiceMockLoginParams{}

	m.LoginDummyMock = mAuthServiceMockLoginDummy{mock: m}
	m.LoginDummyMock.callArgs = []*AuthServiceMockLoginDummyParams{}

	m.RegisterMock = mAuthServiceMockRegister{mock: m}
	m.RegisterMock.callArgs = []*AuthServiceMockRegisterParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthServiceMockLogin struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockLoginExpectation
	expectations       []*AuthServiceMockLoginExpectation

	callArgs []*AuthServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockLoginExpectation specifies expectation struct of the AuthService.Login
type AuthServiceMockLoginExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockLoginParams
	paramPtrs          *AuthServiceMockLoginParamPtrs
	expectationOrigins AuthServiceMockLoginExpectationOrigins
	results            *AuthServiceMockLoginResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockLoginParams contains parameters of the AuthService.Login
type AuthServiceMockLoginParams struct {
	ctx      context.Context
	email    string
	password string
}

// AuthServiceMockLoginParamPtrs contains pointers to parameters of the AuthService.Login
type AuthServiceMockLoginParamPtrs struct {
	ctx      *context.Context
	email    *string
	password *string
}

// AuthServiceMockLoginResults contains results of the AuthService.Login
type AuthServiceMockLoginResults struct {
	s1  string
	err error
}

// AuthServiceMockLoginOrigins contains origins of expectations of the AuthService.Login
type AuthServiceMockLoginExpectationOrigins struct {
	origin         string
	originCtx      string
	originEmail    string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mAuthServiceMockLogin) Optional() *mAuthServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Expect(ctx context.Context, email string, password string) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &AuthServiceMockLoginParams{ctx, email, password}
	mmLogin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectEmailParam2 sets up expected param email for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectEmailParam2(email string) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.email = &email
	mmLogin.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectPasswordParam3 sets up expected param password for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectPasswordParam3(password string) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.password = &password
	mmLogin.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Inspect(f func(ctx context.Context, email string, password string)) *mAuthServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Return(s1 string, err error) *AuthServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &AuthServiceMockLoginResults{s1, err}
	mmLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// Set uses given function f to mock the AuthService.Login method
func (mmLogin *mAuthServiceMockLogin) Set(f func(ctx context.Context, email string, password string) (s1 string, err error)) *AuthServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the AuthService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the AuthService.Login method")
	}

	mmLogin.mock.funcLogin = f
	mmLogin.mock.funcLoginOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// When sets expectation for the AuthService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mAuthServiceMockLogin) When(ctx context.Context, email string, password string) *AuthServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	expectation := &AuthServiceMockLoginExpectation{
		mock:               mmLogin.mock,
		params:             &AuthServiceMockLoginParams{ctx, email, password},
		expectationOrigins: AuthServiceMockLoginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Login return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockLoginExpectation) Then(s1 string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockLoginResults{s1, err}
	return e.mock
}

// Times sets number of times AuthService.Login should be invoked
func (mmLogin *mAuthServiceMockLogin) Times(n uint64) *mAuthServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of AuthServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	mmLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogin
}

func (mmLogin *mAuthServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements mm_service.AuthService
func (mmLogin *AuthServiceMock) Login(ctx context.Context, email string, password string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	mmLogin.t.Helper()

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, email, password)
	}

	mm_params := AuthServiceMockLoginParams{ctx, email, password}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockLoginParams{ctx, email, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogin.LoginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the AuthServiceMock.Login")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, email, password)
	}
	mmLogin.t.Fatalf("Unexpected call to AuthServiceMock.Login. %v %v %v", ctx, email, password)
	return
}

// LoginAfterCounter returns a count of finished AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mAuthServiceMockLogin) Calls() []*AuthServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*AuthServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s", m.LoginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s with params: %#v", m.LoginMock.defaultExpectation.expectationOrigins.origin, *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s", m.funcLoginOrigin)
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Login at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), m.LoginMock.expectedInvocationsOrigin, afterLoginCounter)
	}
}

type mAuthServiceMockLoginDummy struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockLoginDummyExpectation
	expectations       []*AuthServiceMockLoginDummyExpectation

	callArgs []*AuthServiceMockLoginDummyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockLoginDummyExpectation specifies expectation struct of the AuthService.LoginDummy
type AuthServiceMockLoginDummyExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockLoginDummyParams
	paramPtrs          *AuthServiceMockLoginDummyParamPtrs
	expectationOrigins AuthServiceMockLoginDummyExpectationOrigins
	results            *AuthServiceMockLoginDummyResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockLoginDummyParams contains parameters of the AuthService.LoginDummy
type AuthServiceMockLoginDummyParams struct {
	ctx  context.Context
	role string
}

// AuthServiceMockLoginDummyParamPtrs contains pointers to parameters of the AuthService.LoginDummy
type AuthServiceMockLoginDummyParamPtrs struct {
	ctx  *context.Context
	role *string
}

// AuthServiceMockLoginDummyResults contains results of the AuthService.LoginDummy
type AuthServiceMockLoginDummyResults struct {
	s1  string
	err error
}

// AuthServiceMockLoginDummyOrigins contains origins of expectations of the AuthService.LoginDummy
type AuthServiceMockLoginDummyExpectationOrigins struct {
	origin     string
	originCtx  string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoginDummy *mAuthServiceMockLoginDummy) Optional() *mAuthServiceMockLoginDummy {
	mmLoginDummy.optional = true
	return mmLoginDummy
}

// Expect sets up expected params for AuthService.LoginDummy
func (mmLoginDummy *mAuthServiceMockLoginDummy) Expect(ctx context.Context, role string) *mAuthServiceMockLoginDummy {
	if mmLoginDummy.mock.funcLoginDummy != nil {
		mmLoginDummy.mock.t.Fatalf("AuthServiceMock.LoginDummy mock is already set by Set")
	}

	if mmLoginDummy.defaultExpectation == nil {
		mmLoginDummy.defaultExpectation = &AuthServiceMockLoginDummyExpectation{}
	}

	if mmLoginDummy.defaultExpectation.paramPtrs != nil {
		mmLoginDummy.mock.t.Fatalf("AuthServiceMock.LoginDummy mock is already set by ExpectParams functions")
	}

	mmLoginDummy.defaultExpectation.params = &AuthServiceMockLoginDummyParams{ctx, role}
	mmLoginDummy.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLoginDummy.expectations {
		if minimock.Equal(e.params, mmLoginDummy.defaultExpectation.params) {
			mmLoginDummy.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoginDummy.defaultExpectation.params)
		}
	}

	return mmLoginDummy
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.LoginDummy
func (mmLoginDummy *mAuthServiceMockLoginDummy) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockLoginDummy {
	if mmLoginDummy.mock.funcLoginDummy != nil {
		mmLoginDummy.mock.t.Fatalf("AuthServiceMock.LoginDummy mock is already set by Set")
	}

	if mmLoginDummy.defaultExpectation == nil {
		mmLoginDummy.defaultExpectation = &AuthServiceMockLoginDummyExpectation{}
	}

	if mmLoginDummy.defaultExpectation.params != nil {
		mmLoginDummy.mock.t.Fatalf("AuthServiceMock.LoginDummy mock is already set by Expect")
	}

	if mmLoginDummy.defaultExpectation.paramPtrs == nil {
		mmLoginDummy.defaultExpectation.paramPtrs = &AuthServiceMockLoginDummyParamPtrs{}
	}
	mmLoginDummy.defaultExpectation.paramPtrs.ctx = &ctx
	mmLoginDummy.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLoginDummy
}

// ExpectRoleParam2 sets up expected param role for AuthService.LoginDummy
func (mmLoginDummy *mAuthServiceMockLoginDummy) ExpectRoleParam2(role string) *mAuthServiceMockLoginDummy {
	if mmLoginDummy.mock.funcLoginDummy != nil {
		mmLoginDummy.mock.t.Fatalf("AuthServiceMock.LoginDummy mock is already set by Set")
	}

	if mmLoginDummy.defaultExpectation == nil {
		mmLoginDummy.defaultExpectation = &AuthServiceMockLoginDummyExpectation{}
	}

	if mmLoginDummy.defaultExpectation.params != nil {
		mmLoginDummy.mock.t.Fatalf("AuthServiceMock.LoginDummy mock is already set by Expect")
	}

	if mmLoginDummy.defaultExpectation.paramPtrs == nil {
		mmLoginDummy.defaultExpectation.paramPtrs = &AuthServiceMockLoginDummyParamPtrs{}
	}
	mmLoginDummy.defaultExpectation.paramPtrs.role = &role
	mmLoginDummy.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmLoginDummy
}

// Inspect accepts an inspector function that has same arguments as the AuthService.LoginDummy
func (mmLoginDummy *mAuthServiceMockLoginDummy) Inspect(f func(ctx context.Context, role string)) *mAuthServiceMockLoginDummy {
	if mmLoginDummy.mock.inspectFuncLoginDummy != nil {
		mmLoginDummy.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.LoginDummy")
	}

	mmLoginDummy.mock.inspectFuncLoginDummy = f

	return mmLoginDummy
}

// Return sets up results that will be returned by AuthService.LoginDummy
func (mmLoginDummy *mAuthServiceMockLoginDummy) Return(s1 string, err error) *AuthServiceMock {
	if mmLoginDummy.mock.funcLoginDummy != nil {
		mmLoginDummy.mock.t.Fatalf("AuthServiceMock.LoginDummy mock is already set by Set")
	}

	if mmLoginDummy.defaultExpectation == nil {
		mmLoginDummy.defaultExpectation = &AuthServiceMockLoginDummyExpectation{mock: mmLoginDummy.mock}
	}
	mmLoginDummy.defaultExpectation.results = &AuthServiceMockLoginDummyResults{s1, err}
	mmLoginDummy.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLoginDummy.mock
}

// Set uses given function f to mock the AuthService.LoginDummy method
func (mmLoginDummy *mAuthServiceMockLoginDummy) Set(f func(ctx context.Context, role string) (s1 string, err error)) *AuthServiceMock {
	if mmLoginDummy.defaultExpectation != nil {
		mmLoginDummy.mock.t.Fatalf("Default expectation is already set for the AuthService.LoginDummy method")
	}

	if len(mmLoginDummy.expectations) > 0 {
		mmLoginDummy.mock.t.Fatalf("Some expectations are already set for the AuthService.LoginDummy method")
	}

	mmLoginDummy.mock.funcLoginDummy = f
	mmLoginDummy.mock.funcLoginDummyOrigin = minimock.CallerInfo(1)
	return mmLoginDummy.mock
}

// When sets expectation for the AuthService.LoginDummy which will trigger the result defined by the following
// Then helper
func (mmLoginDummy *mAuthServiceMockLoginDummy) When(ctx context.Context, role string) *AuthServiceMockLoginDummyExpectation {
	if mmLoginDummy.mock.funcLoginDummy != nil {
		mmLoginDummy.mock.t.Fatalf("AuthServiceMock.LoginDummy mock is already set by Set")
	}

	expectation := &AuthServiceMockLoginDummyExpectation{
		mock:               mmLoginDummy.mock,
		params:             &AuthServiceMockLoginDummyParams{ctx, role},
		expectationOrigins: AuthServiceMockLoginDummyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLoginDummy.expectations = append(mmLoginDummy.expectations, expectation)
	return expectation
}

// Then sets up AuthService.LoginDummy return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockLoginDummyExpectation) Then(s1 string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockLoginDummyResults{s1, err}
	return e.mock
}

// Times sets number of times AuthService.LoginDummy should be invoked
func (mmLoginDummy *mAuthServiceMockLoginDummy) Times(n uint64) *mAuthServiceMockLoginDummy {
	if n == 0 {
		mmLoginDummy.mock.t.Fatalf("Times of AuthServiceMock.LoginDummy mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLoginDummy.expectedInvocations, n)
	mmLoginDummy.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLoginDummy
}

func (mmLoginDummy *mAuthServiceMockLoginDummy) invocationsDone() bool {
	if len(mmLoginDummy.expectations) == 0 && mmLoginDummy.defaultExpectation == nil && mmLoginDummy.mock.funcLoginDummy == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLoginDummy.mock.afterLoginDummyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLoginDummy.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LoginDummy implements mm_service.AuthService
func (mmLoginDummy *AuthServiceMock) LoginDummy(ctx context.Context, role string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmLoginDummy.beforeLoginDummyCounter, 1)
	defer mm_atomic.AddUint64(&mmLoginDummy.afterLoginDummyCounter, 1)

	mmLoginDummy.t.Helper()

	if mmLoginDummy.inspectFuncLoginDummy != nil {
		mmLoginDummy.inspectFuncLoginDummy(ctx, role)
	}

	mm_params := AuthServiceMockLoginDummyParams{ctx, role}

	// Record call args
	mmLoginDummy.LoginDummyMock.mutex.Lock()
	mmLoginDummy.LoginDummyMock.callArgs = append(mmLoginDummy.LoginDummyMock.callArgs, &mm_params)
	mmLoginDummy.LoginDummyMock.mutex.Unlock()

	for _, e := range mmLoginDummy.LoginDummyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmLoginDummy.LoginDummyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoginDummy.LoginDummyMock.defaultExpectation.Counter, 1)
		mm_want := mmLoginDummy.LoginDummyMock.defaultExpectation.params
		mm_want_ptrs := mmLoginDummy.LoginDummyMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockLoginDummyParams{ctx, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLoginDummy.t.Errorf("AuthServiceMock.LoginDummy got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoginDummy.LoginDummyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmLoginDummy.t.Errorf("AuthServiceMock.LoginDummy got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoginDummy.LoginDummyMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoginDummy.t.Errorf("AuthServiceMock.LoginDummy got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLoginDummy.LoginDummyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoginDummy.LoginDummyMock.defaultExpectation.results
		if mm_results == nil {
			mmLoginDummy.t.Fatal("No results are set for the AuthServiceMock.LoginDummy")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmLoginDummy.funcLoginDummy != nil {
		return mmLoginDummy.funcLoginDummy(ctx, role)
	}
	mmLoginDummy.t.Fatalf("Unexpected call to AuthServiceMock.LoginDummy. %v %v", ctx, role)
	return
}

// LoginDummyAfterCounter returns a count of finished AuthServiceMock.LoginDummy invocations
func (mmLoginDummy *AuthServiceMock) LoginDummyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoginDummy.afterLoginDummyCounter)
}

// LoginDummyBeforeCounter returns a count of AuthServiceMock.LoginDummy invocations
func (mmLoginDummy *AuthServiceMock) LoginDummyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoginDummy.beforeLoginDummyCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.LoginDummy.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoginDummy *mAuthServiceMockLoginDummy) Calls() []*AuthServiceMockLoginDummyParams {
	mmLoginDummy.mutex.RLock()

	argCopy := make([]*AuthServiceMockLoginDummyParams, len(mmLoginDummy.callArgs))
	copy(argCopy, mmLoginDummy.callArgs)

	mmLoginDummy.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDummyDone returns true if the count of the LoginDummy invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockLoginDummyDone() bool {
	if m.LoginDummyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginDummyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginDummyMock.invocationsDone()
}

// MinimockLoginDummyInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockLoginDummyInspect() {
	for _, e := range m.LoginDummyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.LoginDummy at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoginDummyCounter := mm_atomic.LoadUint64(&m.afterLoginDummyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginDummyMock.defaultExpectation != nil && afterLoginDummyCounter < 1 {
		if m.LoginDummyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.LoginDummy at\n%s", m.LoginDummyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.LoginDummy at\n%s with params: %#v", m.LoginDummyMock.defaultExpectation.expectationOrigins.origin, *m.LoginDummyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoginDummy != nil && afterLoginDummyCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.LoginDummy at\n%s", m.funcLoginDummyOrigin)
	}

	if !m.LoginDummyMock.invocationsDone() && afterLoginDummyCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.LoginDummy at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginDummyMock.expectedInvocations), m.LoginDummyMock.expectedInvocationsOrigin, afterLoginDummyCounter)
	}
}

type mAuthServiceMockRegister struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockRegisterExpectation
	expectations       []*AuthServiceMockRegisterExpectation

	callArgs []*AuthServiceMockRegisterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockRegisterExpectation specifies expectation struct of the AuthService.Register
type AuthServiceMockRegisterExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockRegisterParams
	paramPtrs          *AuthServiceMockRegisterParamPtrs
	expectationOrigins AuthServiceMockRegisterExpectationOrigins
	results            *AuthServiceMockRegisterResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockRegisterParams contains parameters of the AuthService.Register
type AuthServiceMockRegisterParams struct {
	ctx      context.Context
	email    string
	password string
	role     string
}

// AuthServiceMockRegisterParamPtrs contains pointers to parameters of the AuthService.Register
type AuthServiceMockRegisterParamPtrs struct {
	ctx      *context.Context
	email    *string
	password *string
	role     *string
}

// AuthServiceMockRegisterResults contains results of the AuthService.Register
type AuthServiceMockRegisterResults struct {
	up1 *model.User
	err error
}

// AuthServiceMockRegisterOrigins contains origins of expectations of the AuthService.Register
type AuthServiceMockRegisterExpectationOrigins struct {
	origin         string
	originCtx      string
	originEmail    string
	originPassword string
	originRole     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegister *mAuthServiceMockRegister) Optional() *mAuthServiceMockRegister {
	mmRegister.optional = true
	return mmRegister
}

// Expect sets up expected params for AuthService.Register
func (mmRegister *mAuthServiceMockRegister) Expect(ctx context.Context, email string, password string, role string) *mAuthServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &AuthServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.paramPtrs != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by ExpectParams functions")
	}

	mmRegister.defaultExpectation.params = &AuthServiceMockRegisterParams{ctx, email, password, role}
	mmRegister.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegister.expectations {
		if minimock.Equal(e.params, mmRegister.defaultExpectation.params) {
			mmRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegister.defaultExpectation.params)
		}
	}

	return mmRegister
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Register
func (mmRegister *mAuthServiceMockRegister) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &AuthServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &AuthServiceMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.ctx = &ctx
	mmRegister.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRegister
}

// ExpectEmailParam2 sets up expected param email for AuthService.Register
func (mmRegister *mAuthServiceMockRegister) ExpectEmailParam2(email string) *mAuthServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &AuthServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &AuthServiceMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.email = &email
	mmRegister.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmRegister
}

// ExpectPasswordParam3 sets up expected param password for AuthService.Register
func (mmRegister *mAuthServiceMockRegister) ExpectPasswordParam3(password string) *mAuthServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &AuthServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &AuthServiceMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.password = &password
	mmRegister.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmRegister
}

// ExpectRoleParam4 sets up expected param role for AuthService.Register
func (mmRegister *mAuthServiceMockRegister) ExpectRoleParam4(role string) *mAuthServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &AuthServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &AuthServiceMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.role = &role
	mmRegister.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmRegister
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Register
func (mmRegister *mAuthServiceMockRegister) Inspect(f func(ctx context.Context, email string, password string, role string)) *mAuthServiceMockRegister {
	if mmRegister.mock.inspectFuncRegister != nil {
		mmRegister.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Register")
	}

	mmRegister.mock.inspectFuncRegister = f

	return mmRegister
}

// Return sets up results that will be returned by AuthService.Register
func (mmRegister *mAuthServiceMockRegister) Return(up1 *model.User, err error) *AuthServiceMock {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &AuthServiceMockRegisterExpectation{mock: mmRegister.mock}
	}
	mmRegister.defaultExpectation.results = &AuthServiceMockRegisterResults{up1, err}
	mmRegister.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegister.mock
}

// Set uses given function f to mock the AuthService.Register method
func (mmRegister *mAuthServiceMockRegister) Set(f func(ctx context.Context, email string, password string, role string) (up1 *model.User, err error)) *AuthServiceMock {
	if mmRegister.defaultExpectation != nil {
		mmRegister.mock.t.Fatalf("Default expectation is already set for the AuthService.Register method")
	}

	if len(mmRegister.expectations) > 0 {
		mmRegister.mock.t.Fatalf("Some expectations are already set for the AuthService.Register method")
	}

	mmRegister.mock.funcRegister = f
	mmRegister.mock.funcRegisterOrigin = minimock.CallerInfo(1)
	return mmRegister.mock
}

// When sets expectation for the AuthService.Register which will trigger the result defined by the following
// Then helper
func (mmRegister *mAuthServiceMockRegister) When(ctx context.Context, email string, password string, role string) *AuthServiceMockRegisterExpectation {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	expectation := &AuthServiceMockRegisterExpectation{
		mock:               mmRegister.mock,
		params:             &AuthServiceMockRegisterParams{ctx, email, password, role},
		expectationOrigins: AuthServiceMockRegisterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegister.expectations = append(mmRegister.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Register return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockRegisterExpectation) Then(up1 *model.User, err error) *AuthServiceMock {
	e.results = &AuthServiceMockRegisterResults{up1, err}
	return e.mock
}

// Times sets number of times AuthService.Register should be invoked
func (mmRegister *mAuthServiceMockRegister) Times(n uint64) *mAuthServiceMockRegister {
	if n == 0 {
		mmRegister.mock.t.Fatalf("Times of AuthServiceMock.Register mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegister.expectedInvocations, n)
	mmRegister.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegister
}

func (mmRegister *mAuthServiceMockRegister) invocationsDone() bool {
	if len(mmRegister.expectations) == 0 && mmRegister.defaultExpectation == nil && mmRegister.mock.funcRegister == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegister.mock.afterRegisterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegister.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Register implements mm_service.AuthService
func (mmRegister *AuthServiceMock) Register(ctx context.Context, email string, password string, role string) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmRegister.beforeRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegister.afterRegisterCounter, 1)

	mmRegister.t.Helper()

	if mmRegister.inspectFuncRegister != nil {
		mmRegister.inspectFuncRegister(ctx, email, password, role)
	}

	mm_params := AuthServiceMockRegisterParams{ctx, email, password, role}

	// Record call args
	mmRegister.RegisterMock.mutex.Lock()
	mmRegister.RegisterMock.callArgs = append(mmRegister.RegisterMock.callArgs, &mm_params)
	mmRegister.RegisterMock.mutex.Unlock()

	for _, e := range mmRegister.RegisterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmRegister.RegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegister.RegisterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegister.RegisterMock.defaultExpectation.params
		mm_want_ptrs := mmRegister.RegisterMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockRegisterParams{ctx, email, password, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRegister.t.Errorf("AuthServiceMock.Register got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmRegister.t.Errorf("AuthServiceMock.Register got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmRegister.t.Errorf("AuthServiceMock.Register got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmRegister.t.Errorf("AuthServiceMock.Register got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegister.t.Errorf("AuthServiceMock.Register got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegister.RegisterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegister.RegisterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegister.t.Fatal("No results are set for the AuthServiceMock.Register")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmRegister.funcRegister != nil {
		return mmRegister.funcRegister(ctx, email, password, role)
	}
	mmRegister.t.Fatalf("Unexpected call to AuthServiceMock.Register. %v %v %v %v", ctx, email, password, role)
	return
}

// RegisterAfterCounter returns a count of finished AuthServiceMock.Register invocations
func (mmRegister *AuthServiceMock) RegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.afterRegisterCounter)
}

// RegisterBeforeCounter returns a count of AuthServiceMock.Register invocations
func (mmRegister *AuthServiceMock) RegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.beforeRegisterCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Register.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegister *mAuthServiceMockRegister) Calls() []*AuthServiceMockRegisterParams {
	mmRegister.mutex.RLock()

	argCopy := make([]*AuthServiceMockRegisterParams, len(mmRegister.callArgs))
	copy(argCopy, mmRegister.callArgs)

	mmRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterDone returns true if the count of the Register invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockRegisterDone() bool {
	if m.RegisterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterMock.invocationsDone()
}

// MinimockRegisterInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockRegisterInspect() {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Register at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterCounter := mm_atomic.LoadUint64(&m.afterRegisterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && afterRegisterCounter < 1 {
		if m.RegisterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.Register at\n%s", m.RegisterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Register at\n%s with params: %#v", m.RegisterMock.defaultExpectation.expectationOrigins.origin, *m.RegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && afterRegisterCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.Register at\n%s", m.funcRegisterOrigin)
	}

	if !m.RegisterMock.invocationsDone() && afterRegisterCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Register at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterMock.expectedInvocations), m.RegisterMock.expectedInvocationsOrigin, afterRegisterCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockLoginInspect()

			m.MinimockLoginDummyInspect()

			m.MinimockRegisterInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockLoginDone() &&
		m.MinimockLoginDummyDone() &&
		m.MinimockRegisterDone()
}
