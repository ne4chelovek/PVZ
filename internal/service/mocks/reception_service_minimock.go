// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i PVZ/internal/service.ReceptionService -o reception_service_minimock.go -n ReceptionServiceMock -p mocks

import (
	"PVZ/internal/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ReceptionServiceMock implements mm_service.ReceptionService
type ReceptionServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddProduct          func(ctx context.Context, pvzID string, productType string) (pp1 *model.Product, err error)
	funcAddProductOrigin    string
	inspectFuncAddProduct   func(ctx context.Context, pvzID string, productType string)
	afterAddProductCounter  uint64
	beforeAddProductCounter uint64
	AddProductMock          mReceptionServiceMockAddProduct

	funcCloseLastReception          func(ctx context.Context, pvzID string) (rp1 *model.Reception, err error)
	funcCloseLastReceptionOrigin    string
	inspectFuncCloseLastReception   func(ctx context.Context, pvzID string)
	afterCloseLastReceptionCounter  uint64
	beforeCloseLastReceptionCounter uint64
	CloseLastReceptionMock          mReceptionServiceMockCloseLastReception

	funcCreateReception          func(ctx context.Context, pvzID string) (rp1 *model.Reception, err error)
	funcCreateReceptionOrigin    string
	inspectFuncCreateReception   func(ctx context.Context, pvzID string)
	afterCreateReceptionCounter  uint64
	beforeCreateReceptionCounter uint64
	CreateReceptionMock          mReceptionServiceMockCreateReception

	funcDeleteLastProduct          func(ctx context.Context, pvzID string) (err error)
	funcDeleteLastProductOrigin    string
	inspectFuncDeleteLastProduct   func(ctx context.Context, pvzID string)
	afterDeleteLastProductCounter  uint64
	beforeDeleteLastProductCounter uint64
	DeleteLastProductMock          mReceptionServiceMockDeleteLastProduct
}

// NewReceptionServiceMock returns a mock for mm_service.ReceptionService
func NewReceptionServiceMock(t minimock.Tester) *ReceptionServiceMock {
	m := &ReceptionServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddProductMock = mReceptionServiceMockAddProduct{mock: m}
	m.AddProductMock.callArgs = []*ReceptionServiceMockAddProductParams{}

	m.CloseLastReceptionMock = mReceptionServiceMockCloseLastReception{mock: m}
	m.CloseLastReceptionMock.callArgs = []*ReceptionServiceMockCloseLastReceptionParams{}

	m.CreateReceptionMock = mReceptionServiceMockCreateReception{mock: m}
	m.CreateReceptionMock.callArgs = []*ReceptionServiceMockCreateReceptionParams{}

	m.DeleteLastProductMock = mReceptionServiceMockDeleteLastProduct{mock: m}
	m.DeleteLastProductMock.callArgs = []*ReceptionServiceMockDeleteLastProductParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mReceptionServiceMockAddProduct struct {
	optional           bool
	mock               *ReceptionServiceMock
	defaultExpectation *ReceptionServiceMockAddProductExpectation
	expectations       []*ReceptionServiceMockAddProductExpectation

	callArgs []*ReceptionServiceMockAddProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionServiceMockAddProductExpectation specifies expectation struct of the ReceptionService.AddProduct
type ReceptionServiceMockAddProductExpectation struct {
	mock               *ReceptionServiceMock
	params             *ReceptionServiceMockAddProductParams
	paramPtrs          *ReceptionServiceMockAddProductParamPtrs
	expectationOrigins ReceptionServiceMockAddProductExpectationOrigins
	results            *ReceptionServiceMockAddProductResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionServiceMockAddProductParams contains parameters of the ReceptionService.AddProduct
type ReceptionServiceMockAddProductParams struct {
	ctx         context.Context
	pvzID       string
	productType string
}

// ReceptionServiceMockAddProductParamPtrs contains pointers to parameters of the ReceptionService.AddProduct
type ReceptionServiceMockAddProductParamPtrs struct {
	ctx         *context.Context
	pvzID       *string
	productType *string
}

// ReceptionServiceMockAddProductResults contains results of the ReceptionService.AddProduct
type ReceptionServiceMockAddProductResults struct {
	pp1 *model.Product
	err error
}

// ReceptionServiceMockAddProductOrigins contains origins of expectations of the ReceptionService.AddProduct
type ReceptionServiceMockAddProductExpectationOrigins struct {
	origin            string
	originCtx         string
	originPvzID       string
	originProductType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddProduct *mReceptionServiceMockAddProduct) Optional() *mReceptionServiceMockAddProduct {
	mmAddProduct.optional = true
	return mmAddProduct
}

// Expect sets up expected params for ReceptionService.AddProduct
func (mmAddProduct *mReceptionServiceMockAddProduct) Expect(ctx context.Context, pvzID string, productType string) *mReceptionServiceMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &ReceptionServiceMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.paramPtrs != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionServiceMock.AddProduct mock is already set by ExpectParams functions")
	}

	mmAddProduct.defaultExpectation.params = &ReceptionServiceMockAddProductParams{ctx, pvzID, productType}
	mmAddProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddProduct.expectations {
		if minimock.Equal(e.params, mmAddProduct.defaultExpectation.params) {
			mmAddProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddProduct.defaultExpectation.params)
		}
	}

	return mmAddProduct
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionService.AddProduct
func (mmAddProduct *mReceptionServiceMockAddProduct) ExpectCtxParam1(ctx context.Context) *mReceptionServiceMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &ReceptionServiceMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionServiceMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &ReceptionServiceMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddProduct
}

// ExpectPvzIDParam2 sets up expected param pvzID for ReceptionService.AddProduct
func (mmAddProduct *mReceptionServiceMockAddProduct) ExpectPvzIDParam2(pvzID string) *mReceptionServiceMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &ReceptionServiceMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionServiceMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &ReceptionServiceMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.pvzID = &pvzID
	mmAddProduct.defaultExpectation.expectationOrigins.originPvzID = minimock.CallerInfo(1)

	return mmAddProduct
}

// ExpectProductTypeParam3 sets up expected param productType for ReceptionService.AddProduct
func (mmAddProduct *mReceptionServiceMockAddProduct) ExpectProductTypeParam3(productType string) *mReceptionServiceMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &ReceptionServiceMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionServiceMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &ReceptionServiceMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.productType = &productType
	mmAddProduct.defaultExpectation.expectationOrigins.originProductType = minimock.CallerInfo(1)

	return mmAddProduct
}

// Inspect accepts an inspector function that has same arguments as the ReceptionService.AddProduct
func (mmAddProduct *mReceptionServiceMockAddProduct) Inspect(f func(ctx context.Context, pvzID string, productType string)) *mReceptionServiceMockAddProduct {
	if mmAddProduct.mock.inspectFuncAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("Inspect function is already set for ReceptionServiceMock.AddProduct")
	}

	mmAddProduct.mock.inspectFuncAddProduct = f

	return mmAddProduct
}

// Return sets up results that will be returned by ReceptionService.AddProduct
func (mmAddProduct *mReceptionServiceMockAddProduct) Return(pp1 *model.Product, err error) *ReceptionServiceMock {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &ReceptionServiceMockAddProductExpectation{mock: mmAddProduct.mock}
	}
	mmAddProduct.defaultExpectation.results = &ReceptionServiceMockAddProductResults{pp1, err}
	mmAddProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddProduct.mock
}

// Set uses given function f to mock the ReceptionService.AddProduct method
func (mmAddProduct *mReceptionServiceMockAddProduct) Set(f func(ctx context.Context, pvzID string, productType string) (pp1 *model.Product, err error)) *ReceptionServiceMock {
	if mmAddProduct.defaultExpectation != nil {
		mmAddProduct.mock.t.Fatalf("Default expectation is already set for the ReceptionService.AddProduct method")
	}

	if len(mmAddProduct.expectations) > 0 {
		mmAddProduct.mock.t.Fatalf("Some expectations are already set for the ReceptionService.AddProduct method")
	}

	mmAddProduct.mock.funcAddProduct = f
	mmAddProduct.mock.funcAddProductOrigin = minimock.CallerInfo(1)
	return mmAddProduct.mock
}

// When sets expectation for the ReceptionService.AddProduct which will trigger the result defined by the following
// Then helper
func (mmAddProduct *mReceptionServiceMockAddProduct) When(ctx context.Context, pvzID string, productType string) *ReceptionServiceMockAddProductExpectation {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("ReceptionServiceMock.AddProduct mock is already set by Set")
	}

	expectation := &ReceptionServiceMockAddProductExpectation{
		mock:               mmAddProduct.mock,
		params:             &ReceptionServiceMockAddProductParams{ctx, pvzID, productType},
		expectationOrigins: ReceptionServiceMockAddProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddProduct.expectations = append(mmAddProduct.expectations, expectation)
	return expectation
}

// Then sets up ReceptionService.AddProduct return parameters for the expectation previously defined by the When method
func (e *ReceptionServiceMockAddProductExpectation) Then(pp1 *model.Product, err error) *ReceptionServiceMock {
	e.results = &ReceptionServiceMockAddProductResults{pp1, err}
	return e.mock
}

// Times sets number of times ReceptionService.AddProduct should be invoked
func (mmAddProduct *mReceptionServiceMockAddProduct) Times(n uint64) *mReceptionServiceMockAddProduct {
	if n == 0 {
		mmAddProduct.mock.t.Fatalf("Times of ReceptionServiceMock.AddProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddProduct.expectedInvocations, n)
	mmAddProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddProduct
}

func (mmAddProduct *mReceptionServiceMockAddProduct) invocationsDone() bool {
	if len(mmAddProduct.expectations) == 0 && mmAddProduct.defaultExpectation == nil && mmAddProduct.mock.funcAddProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddProduct.mock.afterAddProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddProduct implements mm_service.ReceptionService
func (mmAddProduct *ReceptionServiceMock) AddProduct(ctx context.Context, pvzID string, productType string) (pp1 *model.Product, err error) {
	mm_atomic.AddUint64(&mmAddProduct.beforeAddProductCounter, 1)
	defer mm_atomic.AddUint64(&mmAddProduct.afterAddProductCounter, 1)

	mmAddProduct.t.Helper()

	if mmAddProduct.inspectFuncAddProduct != nil {
		mmAddProduct.inspectFuncAddProduct(ctx, pvzID, productType)
	}

	mm_params := ReceptionServiceMockAddProductParams{ctx, pvzID, productType}

	// Record call args
	mmAddProduct.AddProductMock.mutex.Lock()
	mmAddProduct.AddProductMock.callArgs = append(mmAddProduct.AddProductMock.callArgs, &mm_params)
	mmAddProduct.AddProductMock.mutex.Unlock()

	for _, e := range mmAddProduct.AddProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmAddProduct.AddProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddProduct.AddProductMock.defaultExpectation.Counter, 1)
		mm_want := mmAddProduct.AddProductMock.defaultExpectation.params
		mm_want_ptrs := mmAddProduct.AddProductMock.defaultExpectation.paramPtrs

		mm_got := ReceptionServiceMockAddProductParams{ctx, pvzID, productType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddProduct.t.Errorf("ReceptionServiceMock.AddProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzID != nil && !minimock.Equal(*mm_want_ptrs.pvzID, mm_got.pvzID) {
				mmAddProduct.t.Errorf("ReceptionServiceMock.AddProduct got unexpected parameter pvzID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originPvzID, *mm_want_ptrs.pvzID, mm_got.pvzID, minimock.Diff(*mm_want_ptrs.pvzID, mm_got.pvzID))
			}

			if mm_want_ptrs.productType != nil && !minimock.Equal(*mm_want_ptrs.productType, mm_got.productType) {
				mmAddProduct.t.Errorf("ReceptionServiceMock.AddProduct got unexpected parameter productType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originProductType, *mm_want_ptrs.productType, mm_got.productType, minimock.Diff(*mm_want_ptrs.productType, mm_got.productType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddProduct.t.Errorf("ReceptionServiceMock.AddProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddProduct.AddProductMock.defaultExpectation.results
		if mm_results == nil {
			mmAddProduct.t.Fatal("No results are set for the ReceptionServiceMock.AddProduct")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmAddProduct.funcAddProduct != nil {
		return mmAddProduct.funcAddProduct(ctx, pvzID, productType)
	}
	mmAddProduct.t.Fatalf("Unexpected call to ReceptionServiceMock.AddProduct. %v %v %v", ctx, pvzID, productType)
	return
}

// AddProductAfterCounter returns a count of finished ReceptionServiceMock.AddProduct invocations
func (mmAddProduct *ReceptionServiceMock) AddProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.afterAddProductCounter)
}

// AddProductBeforeCounter returns a count of ReceptionServiceMock.AddProduct invocations
func (mmAddProduct *ReceptionServiceMock) AddProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.beforeAddProductCounter)
}

// Calls returns a list of arguments used in each call to ReceptionServiceMock.AddProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddProduct *mReceptionServiceMockAddProduct) Calls() []*ReceptionServiceMockAddProductParams {
	mmAddProduct.mutex.RLock()

	argCopy := make([]*ReceptionServiceMockAddProductParams, len(mmAddProduct.callArgs))
	copy(argCopy, mmAddProduct.callArgs)

	mmAddProduct.mutex.RUnlock()

	return argCopy
}

// MinimockAddProductDone returns true if the count of the AddProduct invocations corresponds
// the number of defined expectations
func (m *ReceptionServiceMock) MinimockAddProductDone() bool {
	if m.AddProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddProductMock.invocationsDone()
}

// MinimockAddProductInspect logs each unmet expectation
func (m *ReceptionServiceMock) MinimockAddProductInspect() {
	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionServiceMock.AddProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddProductCounter := mm_atomic.LoadUint64(&m.afterAddProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddProductMock.defaultExpectation != nil && afterAddProductCounter < 1 {
		if m.AddProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionServiceMock.AddProduct at\n%s", m.AddProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionServiceMock.AddProduct at\n%s with params: %#v", m.AddProductMock.defaultExpectation.expectationOrigins.origin, *m.AddProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddProduct != nil && afterAddProductCounter < 1 {
		m.t.Errorf("Expected call to ReceptionServiceMock.AddProduct at\n%s", m.funcAddProductOrigin)
	}

	if !m.AddProductMock.invocationsDone() && afterAddProductCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionServiceMock.AddProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddProductMock.expectedInvocations), m.AddProductMock.expectedInvocationsOrigin, afterAddProductCounter)
	}
}

type mReceptionServiceMockCloseLastReception struct {
	optional           bool
	mock               *ReceptionServiceMock
	defaultExpectation *ReceptionServiceMockCloseLastReceptionExpectation
	expectations       []*ReceptionServiceMockCloseLastReceptionExpectation

	callArgs []*ReceptionServiceMockCloseLastReceptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionServiceMockCloseLastReceptionExpectation specifies expectation struct of the ReceptionService.CloseLastReception
type ReceptionServiceMockCloseLastReceptionExpectation struct {
	mock               *ReceptionServiceMock
	params             *ReceptionServiceMockCloseLastReceptionParams
	paramPtrs          *ReceptionServiceMockCloseLastReceptionParamPtrs
	expectationOrigins ReceptionServiceMockCloseLastReceptionExpectationOrigins
	results            *ReceptionServiceMockCloseLastReceptionResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionServiceMockCloseLastReceptionParams contains parameters of the ReceptionService.CloseLastReception
type ReceptionServiceMockCloseLastReceptionParams struct {
	ctx   context.Context
	pvzID string
}

// ReceptionServiceMockCloseLastReceptionParamPtrs contains pointers to parameters of the ReceptionService.CloseLastReception
type ReceptionServiceMockCloseLastReceptionParamPtrs struct {
	ctx   *context.Context
	pvzID *string
}

// ReceptionServiceMockCloseLastReceptionResults contains results of the ReceptionService.CloseLastReception
type ReceptionServiceMockCloseLastReceptionResults struct {
	rp1 *model.Reception
	err error
}

// ReceptionServiceMockCloseLastReceptionOrigins contains origins of expectations of the ReceptionService.CloseLastReception
type ReceptionServiceMockCloseLastReceptionExpectationOrigins struct {
	origin      string
	originCtx   string
	originPvzID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) Optional() *mReceptionServiceMockCloseLastReception {
	mmCloseLastReception.optional = true
	return mmCloseLastReception
}

// Expect sets up expected params for ReceptionService.CloseLastReception
func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) Expect(ctx context.Context, pvzID string) *mReceptionServiceMockCloseLastReception {
	if mmCloseLastReception.mock.funcCloseLastReception != nil {
		mmCloseLastReception.mock.t.Fatalf("ReceptionServiceMock.CloseLastReception mock is already set by Set")
	}

	if mmCloseLastReception.defaultExpectation == nil {
		mmCloseLastReception.defaultExpectation = &ReceptionServiceMockCloseLastReceptionExpectation{}
	}

	if mmCloseLastReception.defaultExpectation.paramPtrs != nil {
		mmCloseLastReception.mock.t.Fatalf("ReceptionServiceMock.CloseLastReception mock is already set by ExpectParams functions")
	}

	mmCloseLastReception.defaultExpectation.params = &ReceptionServiceMockCloseLastReceptionParams{ctx, pvzID}
	mmCloseLastReception.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCloseLastReception.expectations {
		if minimock.Equal(e.params, mmCloseLastReception.defaultExpectation.params) {
			mmCloseLastReception.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCloseLastReception.defaultExpectation.params)
		}
	}

	return mmCloseLastReception
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionService.CloseLastReception
func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) ExpectCtxParam1(ctx context.Context) *mReceptionServiceMockCloseLastReception {
	if mmCloseLastReception.mock.funcCloseLastReception != nil {
		mmCloseLastReception.mock.t.Fatalf("ReceptionServiceMock.CloseLastReception mock is already set by Set")
	}

	if mmCloseLastReception.defaultExpectation == nil {
		mmCloseLastReception.defaultExpectation = &ReceptionServiceMockCloseLastReceptionExpectation{}
	}

	if mmCloseLastReception.defaultExpectation.params != nil {
		mmCloseLastReception.mock.t.Fatalf("ReceptionServiceMock.CloseLastReception mock is already set by Expect")
	}

	if mmCloseLastReception.defaultExpectation.paramPtrs == nil {
		mmCloseLastReception.defaultExpectation.paramPtrs = &ReceptionServiceMockCloseLastReceptionParamPtrs{}
	}
	mmCloseLastReception.defaultExpectation.paramPtrs.ctx = &ctx
	mmCloseLastReception.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCloseLastReception
}

// ExpectPvzIDParam2 sets up expected param pvzID for ReceptionService.CloseLastReception
func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) ExpectPvzIDParam2(pvzID string) *mReceptionServiceMockCloseLastReception {
	if mmCloseLastReception.mock.funcCloseLastReception != nil {
		mmCloseLastReception.mock.t.Fatalf("ReceptionServiceMock.CloseLastReception mock is already set by Set")
	}

	if mmCloseLastReception.defaultExpectation == nil {
		mmCloseLastReception.defaultExpectation = &ReceptionServiceMockCloseLastReceptionExpectation{}
	}

	if mmCloseLastReception.defaultExpectation.params != nil {
		mmCloseLastReception.mock.t.Fatalf("ReceptionServiceMock.CloseLastReception mock is already set by Expect")
	}

	if mmCloseLastReception.defaultExpectation.paramPtrs == nil {
		mmCloseLastReception.defaultExpectation.paramPtrs = &ReceptionServiceMockCloseLastReceptionParamPtrs{}
	}
	mmCloseLastReception.defaultExpectation.paramPtrs.pvzID = &pvzID
	mmCloseLastReception.defaultExpectation.expectationOrigins.originPvzID = minimock.CallerInfo(1)

	return mmCloseLastReception
}

// Inspect accepts an inspector function that has same arguments as the ReceptionService.CloseLastReception
func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) Inspect(f func(ctx context.Context, pvzID string)) *mReceptionServiceMockCloseLastReception {
	if mmCloseLastReception.mock.inspectFuncCloseLastReception != nil {
		mmCloseLastReception.mock.t.Fatalf("Inspect function is already set for ReceptionServiceMock.CloseLastReception")
	}

	mmCloseLastReception.mock.inspectFuncCloseLastReception = f

	return mmCloseLastReception
}

// Return sets up results that will be returned by ReceptionService.CloseLastReception
func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) Return(rp1 *model.Reception, err error) *ReceptionServiceMock {
	if mmCloseLastReception.mock.funcCloseLastReception != nil {
		mmCloseLastReception.mock.t.Fatalf("ReceptionServiceMock.CloseLastReception mock is already set by Set")
	}

	if mmCloseLastReception.defaultExpectation == nil {
		mmCloseLastReception.defaultExpectation = &ReceptionServiceMockCloseLastReceptionExpectation{mock: mmCloseLastReception.mock}
	}
	mmCloseLastReception.defaultExpectation.results = &ReceptionServiceMockCloseLastReceptionResults{rp1, err}
	mmCloseLastReception.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCloseLastReception.mock
}

// Set uses given function f to mock the ReceptionService.CloseLastReception method
func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) Set(f func(ctx context.Context, pvzID string) (rp1 *model.Reception, err error)) *ReceptionServiceMock {
	if mmCloseLastReception.defaultExpectation != nil {
		mmCloseLastReception.mock.t.Fatalf("Default expectation is already set for the ReceptionService.CloseLastReception method")
	}

	if len(mmCloseLastReception.expectations) > 0 {
		mmCloseLastReception.mock.t.Fatalf("Some expectations are already set for the ReceptionService.CloseLastReception method")
	}

	mmCloseLastReception.mock.funcCloseLastReception = f
	mmCloseLastReception.mock.funcCloseLastReceptionOrigin = minimock.CallerInfo(1)
	return mmCloseLastReception.mock
}

// When sets expectation for the ReceptionService.CloseLastReception which will trigger the result defined by the following
// Then helper
func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) When(ctx context.Context, pvzID string) *ReceptionServiceMockCloseLastReceptionExpectation {
	if mmCloseLastReception.mock.funcCloseLastReception != nil {
		mmCloseLastReception.mock.t.Fatalf("ReceptionServiceMock.CloseLastReception mock is already set by Set")
	}

	expectation := &ReceptionServiceMockCloseLastReceptionExpectation{
		mock:               mmCloseLastReception.mock,
		params:             &ReceptionServiceMockCloseLastReceptionParams{ctx, pvzID},
		expectationOrigins: ReceptionServiceMockCloseLastReceptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCloseLastReception.expectations = append(mmCloseLastReception.expectations, expectation)
	return expectation
}

// Then sets up ReceptionService.CloseLastReception return parameters for the expectation previously defined by the When method
func (e *ReceptionServiceMockCloseLastReceptionExpectation) Then(rp1 *model.Reception, err error) *ReceptionServiceMock {
	e.results = &ReceptionServiceMockCloseLastReceptionResults{rp1, err}
	return e.mock
}

// Times sets number of times ReceptionService.CloseLastReception should be invoked
func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) Times(n uint64) *mReceptionServiceMockCloseLastReception {
	if n == 0 {
		mmCloseLastReception.mock.t.Fatalf("Times of ReceptionServiceMock.CloseLastReception mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCloseLastReception.expectedInvocations, n)
	mmCloseLastReception.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCloseLastReception
}

func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) invocationsDone() bool {
	if len(mmCloseLastReception.expectations) == 0 && mmCloseLastReception.defaultExpectation == nil && mmCloseLastReception.mock.funcCloseLastReception == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCloseLastReception.mock.afterCloseLastReceptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCloseLastReception.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CloseLastReception implements mm_service.ReceptionService
func (mmCloseLastReception *ReceptionServiceMock) CloseLastReception(ctx context.Context, pvzID string) (rp1 *model.Reception, err error) {
	mm_atomic.AddUint64(&mmCloseLastReception.beforeCloseLastReceptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCloseLastReception.afterCloseLastReceptionCounter, 1)

	mmCloseLastReception.t.Helper()

	if mmCloseLastReception.inspectFuncCloseLastReception != nil {
		mmCloseLastReception.inspectFuncCloseLastReception(ctx, pvzID)
	}

	mm_params := ReceptionServiceMockCloseLastReceptionParams{ctx, pvzID}

	// Record call args
	mmCloseLastReception.CloseLastReceptionMock.mutex.Lock()
	mmCloseLastReception.CloseLastReceptionMock.callArgs = append(mmCloseLastReception.CloseLastReceptionMock.callArgs, &mm_params)
	mmCloseLastReception.CloseLastReceptionMock.mutex.Unlock()

	for _, e := range mmCloseLastReception.CloseLastReceptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCloseLastReception.CloseLastReceptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCloseLastReception.CloseLastReceptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCloseLastReception.CloseLastReceptionMock.defaultExpectation.params
		mm_want_ptrs := mmCloseLastReception.CloseLastReceptionMock.defaultExpectation.paramPtrs

		mm_got := ReceptionServiceMockCloseLastReceptionParams{ctx, pvzID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCloseLastReception.t.Errorf("ReceptionServiceMock.CloseLastReception got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseLastReception.CloseLastReceptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzID != nil && !minimock.Equal(*mm_want_ptrs.pvzID, mm_got.pvzID) {
				mmCloseLastReception.t.Errorf("ReceptionServiceMock.CloseLastReception got unexpected parameter pvzID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseLastReception.CloseLastReceptionMock.defaultExpectation.expectationOrigins.originPvzID, *mm_want_ptrs.pvzID, mm_got.pvzID, minimock.Diff(*mm_want_ptrs.pvzID, mm_got.pvzID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCloseLastReception.t.Errorf("ReceptionServiceMock.CloseLastReception got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCloseLastReception.CloseLastReceptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCloseLastReception.CloseLastReceptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCloseLastReception.t.Fatal("No results are set for the ReceptionServiceMock.CloseLastReception")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCloseLastReception.funcCloseLastReception != nil {
		return mmCloseLastReception.funcCloseLastReception(ctx, pvzID)
	}
	mmCloseLastReception.t.Fatalf("Unexpected call to ReceptionServiceMock.CloseLastReception. %v %v", ctx, pvzID)
	return
}

// CloseLastReceptionAfterCounter returns a count of finished ReceptionServiceMock.CloseLastReception invocations
func (mmCloseLastReception *ReceptionServiceMock) CloseLastReceptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseLastReception.afterCloseLastReceptionCounter)
}

// CloseLastReceptionBeforeCounter returns a count of ReceptionServiceMock.CloseLastReception invocations
func (mmCloseLastReception *ReceptionServiceMock) CloseLastReceptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseLastReception.beforeCloseLastReceptionCounter)
}

// Calls returns a list of arguments used in each call to ReceptionServiceMock.CloseLastReception.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCloseLastReception *mReceptionServiceMockCloseLastReception) Calls() []*ReceptionServiceMockCloseLastReceptionParams {
	mmCloseLastReception.mutex.RLock()

	argCopy := make([]*ReceptionServiceMockCloseLastReceptionParams, len(mmCloseLastReception.callArgs))
	copy(argCopy, mmCloseLastReception.callArgs)

	mmCloseLastReception.mutex.RUnlock()

	return argCopy
}

// MinimockCloseLastReceptionDone returns true if the count of the CloseLastReception invocations corresponds
// the number of defined expectations
func (m *ReceptionServiceMock) MinimockCloseLastReceptionDone() bool {
	if m.CloseLastReceptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseLastReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseLastReceptionMock.invocationsDone()
}

// MinimockCloseLastReceptionInspect logs each unmet expectation
func (m *ReceptionServiceMock) MinimockCloseLastReceptionInspect() {
	for _, e := range m.CloseLastReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionServiceMock.CloseLastReception at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCloseLastReceptionCounter := mm_atomic.LoadUint64(&m.afterCloseLastReceptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseLastReceptionMock.defaultExpectation != nil && afterCloseLastReceptionCounter < 1 {
		if m.CloseLastReceptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionServiceMock.CloseLastReception at\n%s", m.CloseLastReceptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionServiceMock.CloseLastReception at\n%s with params: %#v", m.CloseLastReceptionMock.defaultExpectation.expectationOrigins.origin, *m.CloseLastReceptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseLastReception != nil && afterCloseLastReceptionCounter < 1 {
		m.t.Errorf("Expected call to ReceptionServiceMock.CloseLastReception at\n%s", m.funcCloseLastReceptionOrigin)
	}

	if !m.CloseLastReceptionMock.invocationsDone() && afterCloseLastReceptionCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionServiceMock.CloseLastReception at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseLastReceptionMock.expectedInvocations), m.CloseLastReceptionMock.expectedInvocationsOrigin, afterCloseLastReceptionCounter)
	}
}

type mReceptionServiceMockCreateReception struct {
	optional           bool
	mock               *ReceptionServiceMock
	defaultExpectation *ReceptionServiceMockCreateReceptionExpectation
	expectations       []*ReceptionServiceMockCreateReceptionExpectation

	callArgs []*ReceptionServiceMockCreateReceptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionServiceMockCreateReceptionExpectation specifies expectation struct of the ReceptionService.CreateReception
type ReceptionServiceMockCreateReceptionExpectation struct {
	mock               *ReceptionServiceMock
	params             *ReceptionServiceMockCreateReceptionParams
	paramPtrs          *ReceptionServiceMockCreateReceptionParamPtrs
	expectationOrigins ReceptionServiceMockCreateReceptionExpectationOrigins
	results            *ReceptionServiceMockCreateReceptionResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionServiceMockCreateReceptionParams contains parameters of the ReceptionService.CreateReception
type ReceptionServiceMockCreateReceptionParams struct {
	ctx   context.Context
	pvzID string
}

// ReceptionServiceMockCreateReceptionParamPtrs contains pointers to parameters of the ReceptionService.CreateReception
type ReceptionServiceMockCreateReceptionParamPtrs struct {
	ctx   *context.Context
	pvzID *string
}

// ReceptionServiceMockCreateReceptionResults contains results of the ReceptionService.CreateReception
type ReceptionServiceMockCreateReceptionResults struct {
	rp1 *model.Reception
	err error
}

// ReceptionServiceMockCreateReceptionOrigins contains origins of expectations of the ReceptionService.CreateReception
type ReceptionServiceMockCreateReceptionExpectationOrigins struct {
	origin      string
	originCtx   string
	originPvzID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateReception *mReceptionServiceMockCreateReception) Optional() *mReceptionServiceMockCreateReception {
	mmCreateReception.optional = true
	return mmCreateReception
}

// Expect sets up expected params for ReceptionService.CreateReception
func (mmCreateReception *mReceptionServiceMockCreateReception) Expect(ctx context.Context, pvzID string) *mReceptionServiceMockCreateReception {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &ReceptionServiceMockCreateReceptionExpectation{}
	}

	if mmCreateReception.defaultExpectation.paramPtrs != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by ExpectParams functions")
	}

	mmCreateReception.defaultExpectation.params = &ReceptionServiceMockCreateReceptionParams{ctx, pvzID}
	mmCreateReception.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateReception.expectations {
		if minimock.Equal(e.params, mmCreateReception.defaultExpectation.params) {
			mmCreateReception.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateReception.defaultExpectation.params)
		}
	}

	return mmCreateReception
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionService.CreateReception
func (mmCreateReception *mReceptionServiceMockCreateReception) ExpectCtxParam1(ctx context.Context) *mReceptionServiceMockCreateReception {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &ReceptionServiceMockCreateReceptionExpectation{}
	}

	if mmCreateReception.defaultExpectation.params != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Expect")
	}

	if mmCreateReception.defaultExpectation.paramPtrs == nil {
		mmCreateReception.defaultExpectation.paramPtrs = &ReceptionServiceMockCreateReceptionParamPtrs{}
	}
	mmCreateReception.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateReception.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateReception
}

// ExpectPvzIDParam2 sets up expected param pvzID for ReceptionService.CreateReception
func (mmCreateReception *mReceptionServiceMockCreateReception) ExpectPvzIDParam2(pvzID string) *mReceptionServiceMockCreateReception {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &ReceptionServiceMockCreateReceptionExpectation{}
	}

	if mmCreateReception.defaultExpectation.params != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Expect")
	}

	if mmCreateReception.defaultExpectation.paramPtrs == nil {
		mmCreateReception.defaultExpectation.paramPtrs = &ReceptionServiceMockCreateReceptionParamPtrs{}
	}
	mmCreateReception.defaultExpectation.paramPtrs.pvzID = &pvzID
	mmCreateReception.defaultExpectation.expectationOrigins.originPvzID = minimock.CallerInfo(1)

	return mmCreateReception
}

// Inspect accepts an inspector function that has same arguments as the ReceptionService.CreateReception
func (mmCreateReception *mReceptionServiceMockCreateReception) Inspect(f func(ctx context.Context, pvzID string)) *mReceptionServiceMockCreateReception {
	if mmCreateReception.mock.inspectFuncCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("Inspect function is already set for ReceptionServiceMock.CreateReception")
	}

	mmCreateReception.mock.inspectFuncCreateReception = f

	return mmCreateReception
}

// Return sets up results that will be returned by ReceptionService.CreateReception
func (mmCreateReception *mReceptionServiceMockCreateReception) Return(rp1 *model.Reception, err error) *ReceptionServiceMock {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &ReceptionServiceMockCreateReceptionExpectation{mock: mmCreateReception.mock}
	}
	mmCreateReception.defaultExpectation.results = &ReceptionServiceMockCreateReceptionResults{rp1, err}
	mmCreateReception.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateReception.mock
}

// Set uses given function f to mock the ReceptionService.CreateReception method
func (mmCreateReception *mReceptionServiceMockCreateReception) Set(f func(ctx context.Context, pvzID string) (rp1 *model.Reception, err error)) *ReceptionServiceMock {
	if mmCreateReception.defaultExpectation != nil {
		mmCreateReception.mock.t.Fatalf("Default expectation is already set for the ReceptionService.CreateReception method")
	}

	if len(mmCreateReception.expectations) > 0 {
		mmCreateReception.mock.t.Fatalf("Some expectations are already set for the ReceptionService.CreateReception method")
	}

	mmCreateReception.mock.funcCreateReception = f
	mmCreateReception.mock.funcCreateReceptionOrigin = minimock.CallerInfo(1)
	return mmCreateReception.mock
}

// When sets expectation for the ReceptionService.CreateReception which will trigger the result defined by the following
// Then helper
func (mmCreateReception *mReceptionServiceMockCreateReception) When(ctx context.Context, pvzID string) *ReceptionServiceMockCreateReceptionExpectation {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Set")
	}

	expectation := &ReceptionServiceMockCreateReceptionExpectation{
		mock:               mmCreateReception.mock,
		params:             &ReceptionServiceMockCreateReceptionParams{ctx, pvzID},
		expectationOrigins: ReceptionServiceMockCreateReceptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateReception.expectations = append(mmCreateReception.expectations, expectation)
	return expectation
}

// Then sets up ReceptionService.CreateReception return parameters for the expectation previously defined by the When method
func (e *ReceptionServiceMockCreateReceptionExpectation) Then(rp1 *model.Reception, err error) *ReceptionServiceMock {
	e.results = &ReceptionServiceMockCreateReceptionResults{rp1, err}
	return e.mock
}

// Times sets number of times ReceptionService.CreateReception should be invoked
func (mmCreateReception *mReceptionServiceMockCreateReception) Times(n uint64) *mReceptionServiceMockCreateReception {
	if n == 0 {
		mmCreateReception.mock.t.Fatalf("Times of ReceptionServiceMock.CreateReception mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateReception.expectedInvocations, n)
	mmCreateReception.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateReception
}

func (mmCreateReception *mReceptionServiceMockCreateReception) invocationsDone() bool {
	if len(mmCreateReception.expectations) == 0 && mmCreateReception.defaultExpectation == nil && mmCreateReception.mock.funcCreateReception == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateReception.mock.afterCreateReceptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateReception.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateReception implements mm_service.ReceptionService
func (mmCreateReception *ReceptionServiceMock) CreateReception(ctx context.Context, pvzID string) (rp1 *model.Reception, err error) {
	mm_atomic.AddUint64(&mmCreateReception.beforeCreateReceptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateReception.afterCreateReceptionCounter, 1)

	mmCreateReception.t.Helper()

	if mmCreateReception.inspectFuncCreateReception != nil {
		mmCreateReception.inspectFuncCreateReception(ctx, pvzID)
	}

	mm_params := ReceptionServiceMockCreateReceptionParams{ctx, pvzID}

	// Record call args
	mmCreateReception.CreateReceptionMock.mutex.Lock()
	mmCreateReception.CreateReceptionMock.callArgs = append(mmCreateReception.CreateReceptionMock.callArgs, &mm_params)
	mmCreateReception.CreateReceptionMock.mutex.Unlock()

	for _, e := range mmCreateReception.CreateReceptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCreateReception.CreateReceptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateReception.CreateReceptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateReception.CreateReceptionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateReception.CreateReceptionMock.defaultExpectation.paramPtrs

		mm_got := ReceptionServiceMockCreateReceptionParams{ctx, pvzID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateReception.t.Errorf("ReceptionServiceMock.CreateReception got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReception.CreateReceptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzID != nil && !minimock.Equal(*mm_want_ptrs.pvzID, mm_got.pvzID) {
				mmCreateReception.t.Errorf("ReceptionServiceMock.CreateReception got unexpected parameter pvzID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReception.CreateReceptionMock.defaultExpectation.expectationOrigins.originPvzID, *mm_want_ptrs.pvzID, mm_got.pvzID, minimock.Diff(*mm_want_ptrs.pvzID, mm_got.pvzID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateReception.t.Errorf("ReceptionServiceMock.CreateReception got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateReception.CreateReceptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateReception.CreateReceptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateReception.t.Fatal("No results are set for the ReceptionServiceMock.CreateReception")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCreateReception.funcCreateReception != nil {
		return mmCreateReception.funcCreateReception(ctx, pvzID)
	}
	mmCreateReception.t.Fatalf("Unexpected call to ReceptionServiceMock.CreateReception. %v %v", ctx, pvzID)
	return
}

// CreateReceptionAfterCounter returns a count of finished ReceptionServiceMock.CreateReception invocations
func (mmCreateReception *ReceptionServiceMock) CreateReceptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReception.afterCreateReceptionCounter)
}

// CreateReceptionBeforeCounter returns a count of ReceptionServiceMock.CreateReception invocations
func (mmCreateReception *ReceptionServiceMock) CreateReceptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReception.beforeCreateReceptionCounter)
}

// Calls returns a list of arguments used in each call to ReceptionServiceMock.CreateReception.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateReception *mReceptionServiceMockCreateReception) Calls() []*ReceptionServiceMockCreateReceptionParams {
	mmCreateReception.mutex.RLock()

	argCopy := make([]*ReceptionServiceMockCreateReceptionParams, len(mmCreateReception.callArgs))
	copy(argCopy, mmCreateReception.callArgs)

	mmCreateReception.mutex.RUnlock()

	return argCopy
}

// MinimockCreateReceptionDone returns true if the count of the CreateReception invocations corresponds
// the number of defined expectations
func (m *ReceptionServiceMock) MinimockCreateReceptionDone() bool {
	if m.CreateReceptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateReceptionMock.invocationsDone()
}

// MinimockCreateReceptionInspect logs each unmet expectation
func (m *ReceptionServiceMock) MinimockCreateReceptionInspect() {
	for _, e := range m.CreateReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionServiceMock.CreateReception at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateReceptionCounter := mm_atomic.LoadUint64(&m.afterCreateReceptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReceptionMock.defaultExpectation != nil && afterCreateReceptionCounter < 1 {
		if m.CreateReceptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionServiceMock.CreateReception at\n%s", m.CreateReceptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionServiceMock.CreateReception at\n%s with params: %#v", m.CreateReceptionMock.defaultExpectation.expectationOrigins.origin, *m.CreateReceptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReception != nil && afterCreateReceptionCounter < 1 {
		m.t.Errorf("Expected call to ReceptionServiceMock.CreateReception at\n%s", m.funcCreateReceptionOrigin)
	}

	if !m.CreateReceptionMock.invocationsDone() && afterCreateReceptionCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionServiceMock.CreateReception at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateReceptionMock.expectedInvocations), m.CreateReceptionMock.expectedInvocationsOrigin, afterCreateReceptionCounter)
	}
}

type mReceptionServiceMockDeleteLastProduct struct {
	optional           bool
	mock               *ReceptionServiceMock
	defaultExpectation *ReceptionServiceMockDeleteLastProductExpectation
	expectations       []*ReceptionServiceMockDeleteLastProductExpectation

	callArgs []*ReceptionServiceMockDeleteLastProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionServiceMockDeleteLastProductExpectation specifies expectation struct of the ReceptionService.DeleteLastProduct
type ReceptionServiceMockDeleteLastProductExpectation struct {
	mock               *ReceptionServiceMock
	params             *ReceptionServiceMockDeleteLastProductParams
	paramPtrs          *ReceptionServiceMockDeleteLastProductParamPtrs
	expectationOrigins ReceptionServiceMockDeleteLastProductExpectationOrigins
	results            *ReceptionServiceMockDeleteLastProductResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionServiceMockDeleteLastProductParams contains parameters of the ReceptionService.DeleteLastProduct
type ReceptionServiceMockDeleteLastProductParams struct {
	ctx   context.Context
	pvzID string
}

// ReceptionServiceMockDeleteLastProductParamPtrs contains pointers to parameters of the ReceptionService.DeleteLastProduct
type ReceptionServiceMockDeleteLastProductParamPtrs struct {
	ctx   *context.Context
	pvzID *string
}

// ReceptionServiceMockDeleteLastProductResults contains results of the ReceptionService.DeleteLastProduct
type ReceptionServiceMockDeleteLastProductResults struct {
	err error
}

// ReceptionServiceMockDeleteLastProductOrigins contains origins of expectations of the ReceptionService.DeleteLastProduct
type ReceptionServiceMockDeleteLastProductExpectationOrigins struct {
	origin      string
	originCtx   string
	originPvzID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) Optional() *mReceptionServiceMockDeleteLastProduct {
	mmDeleteLastProduct.optional = true
	return mmDeleteLastProduct
}

// Expect sets up expected params for ReceptionService.DeleteLastProduct
func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) Expect(ctx context.Context, pvzID string) *mReceptionServiceMockDeleteLastProduct {
	if mmDeleteLastProduct.mock.funcDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("ReceptionServiceMock.DeleteLastProduct mock is already set by Set")
	}

	if mmDeleteLastProduct.defaultExpectation == nil {
		mmDeleteLastProduct.defaultExpectation = &ReceptionServiceMockDeleteLastProductExpectation{}
	}

	if mmDeleteLastProduct.defaultExpectation.paramPtrs != nil {
		mmDeleteLastProduct.mock.t.Fatalf("ReceptionServiceMock.DeleteLastProduct mock is already set by ExpectParams functions")
	}

	mmDeleteLastProduct.defaultExpectation.params = &ReceptionServiceMockDeleteLastProductParams{ctx, pvzID}
	mmDeleteLastProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteLastProduct.expectations {
		if minimock.Equal(e.params, mmDeleteLastProduct.defaultExpectation.params) {
			mmDeleteLastProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteLastProduct.defaultExpectation.params)
		}
	}

	return mmDeleteLastProduct
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionService.DeleteLastProduct
func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) ExpectCtxParam1(ctx context.Context) *mReceptionServiceMockDeleteLastProduct {
	if mmDeleteLastProduct.mock.funcDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("ReceptionServiceMock.DeleteLastProduct mock is already set by Set")
	}

	if mmDeleteLastProduct.defaultExpectation == nil {
		mmDeleteLastProduct.defaultExpectation = &ReceptionServiceMockDeleteLastProductExpectation{}
	}

	if mmDeleteLastProduct.defaultExpectation.params != nil {
		mmDeleteLastProduct.mock.t.Fatalf("ReceptionServiceMock.DeleteLastProduct mock is already set by Expect")
	}

	if mmDeleteLastProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteLastProduct.defaultExpectation.paramPtrs = &ReceptionServiceMockDeleteLastProductParamPtrs{}
	}
	mmDeleteLastProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteLastProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteLastProduct
}

// ExpectPvzIDParam2 sets up expected param pvzID for ReceptionService.DeleteLastProduct
func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) ExpectPvzIDParam2(pvzID string) *mReceptionServiceMockDeleteLastProduct {
	if mmDeleteLastProduct.mock.funcDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("ReceptionServiceMock.DeleteLastProduct mock is already set by Set")
	}

	if mmDeleteLastProduct.defaultExpectation == nil {
		mmDeleteLastProduct.defaultExpectation = &ReceptionServiceMockDeleteLastProductExpectation{}
	}

	if mmDeleteLastProduct.defaultExpectation.params != nil {
		mmDeleteLastProduct.mock.t.Fatalf("ReceptionServiceMock.DeleteLastProduct mock is already set by Expect")
	}

	if mmDeleteLastProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteLastProduct.defaultExpectation.paramPtrs = &ReceptionServiceMockDeleteLastProductParamPtrs{}
	}
	mmDeleteLastProduct.defaultExpectation.paramPtrs.pvzID = &pvzID
	mmDeleteLastProduct.defaultExpectation.expectationOrigins.originPvzID = minimock.CallerInfo(1)

	return mmDeleteLastProduct
}

// Inspect accepts an inspector function that has same arguments as the ReceptionService.DeleteLastProduct
func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) Inspect(f func(ctx context.Context, pvzID string)) *mReceptionServiceMockDeleteLastProduct {
	if mmDeleteLastProduct.mock.inspectFuncDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("Inspect function is already set for ReceptionServiceMock.DeleteLastProduct")
	}

	mmDeleteLastProduct.mock.inspectFuncDeleteLastProduct = f

	return mmDeleteLastProduct
}

// Return sets up results that will be returned by ReceptionService.DeleteLastProduct
func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) Return(err error) *ReceptionServiceMock {
	if mmDeleteLastProduct.mock.funcDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("ReceptionServiceMock.DeleteLastProduct mock is already set by Set")
	}

	if mmDeleteLastProduct.defaultExpectation == nil {
		mmDeleteLastProduct.defaultExpectation = &ReceptionServiceMockDeleteLastProductExpectation{mock: mmDeleteLastProduct.mock}
	}
	mmDeleteLastProduct.defaultExpectation.results = &ReceptionServiceMockDeleteLastProductResults{err}
	mmDeleteLastProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteLastProduct.mock
}

// Set uses given function f to mock the ReceptionService.DeleteLastProduct method
func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) Set(f func(ctx context.Context, pvzID string) (err error)) *ReceptionServiceMock {
	if mmDeleteLastProduct.defaultExpectation != nil {
		mmDeleteLastProduct.mock.t.Fatalf("Default expectation is already set for the ReceptionService.DeleteLastProduct method")
	}

	if len(mmDeleteLastProduct.expectations) > 0 {
		mmDeleteLastProduct.mock.t.Fatalf("Some expectations are already set for the ReceptionService.DeleteLastProduct method")
	}

	mmDeleteLastProduct.mock.funcDeleteLastProduct = f
	mmDeleteLastProduct.mock.funcDeleteLastProductOrigin = minimock.CallerInfo(1)
	return mmDeleteLastProduct.mock
}

// When sets expectation for the ReceptionService.DeleteLastProduct which will trigger the result defined by the following
// Then helper
func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) When(ctx context.Context, pvzID string) *ReceptionServiceMockDeleteLastProductExpectation {
	if mmDeleteLastProduct.mock.funcDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("ReceptionServiceMock.DeleteLastProduct mock is already set by Set")
	}

	expectation := &ReceptionServiceMockDeleteLastProductExpectation{
		mock:               mmDeleteLastProduct.mock,
		params:             &ReceptionServiceMockDeleteLastProductParams{ctx, pvzID},
		expectationOrigins: ReceptionServiceMockDeleteLastProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteLastProduct.expectations = append(mmDeleteLastProduct.expectations, expectation)
	return expectation
}

// Then sets up ReceptionService.DeleteLastProduct return parameters for the expectation previously defined by the When method
func (e *ReceptionServiceMockDeleteLastProductExpectation) Then(err error) *ReceptionServiceMock {
	e.results = &ReceptionServiceMockDeleteLastProductResults{err}
	return e.mock
}

// Times sets number of times ReceptionService.DeleteLastProduct should be invoked
func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) Times(n uint64) *mReceptionServiceMockDeleteLastProduct {
	if n == 0 {
		mmDeleteLastProduct.mock.t.Fatalf("Times of ReceptionServiceMock.DeleteLastProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteLastProduct.expectedInvocations, n)
	mmDeleteLastProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteLastProduct
}

func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) invocationsDone() bool {
	if len(mmDeleteLastProduct.expectations) == 0 && mmDeleteLastProduct.defaultExpectation == nil && mmDeleteLastProduct.mock.funcDeleteLastProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteLastProduct.mock.afterDeleteLastProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteLastProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteLastProduct implements mm_service.ReceptionService
func (mmDeleteLastProduct *ReceptionServiceMock) DeleteLastProduct(ctx context.Context, pvzID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteLastProduct.beforeDeleteLastProductCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteLastProduct.afterDeleteLastProductCounter, 1)

	mmDeleteLastProduct.t.Helper()

	if mmDeleteLastProduct.inspectFuncDeleteLastProduct != nil {
		mmDeleteLastProduct.inspectFuncDeleteLastProduct(ctx, pvzID)
	}

	mm_params := ReceptionServiceMockDeleteLastProductParams{ctx, pvzID}

	// Record call args
	mmDeleteLastProduct.DeleteLastProductMock.mutex.Lock()
	mmDeleteLastProduct.DeleteLastProductMock.callArgs = append(mmDeleteLastProduct.DeleteLastProductMock.callArgs, &mm_params)
	mmDeleteLastProduct.DeleteLastProductMock.mutex.Unlock()

	for _, e := range mmDeleteLastProduct.DeleteLastProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.paramPtrs

		mm_got := ReceptionServiceMockDeleteLastProductParams{ctx, pvzID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteLastProduct.t.Errorf("ReceptionServiceMock.DeleteLastProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzID != nil && !minimock.Equal(*mm_want_ptrs.pvzID, mm_got.pvzID) {
				mmDeleteLastProduct.t.Errorf("ReceptionServiceMock.DeleteLastProduct got unexpected parameter pvzID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.expectationOrigins.originPvzID, *mm_want_ptrs.pvzID, mm_got.pvzID, minimock.Diff(*mm_want_ptrs.pvzID, mm_got.pvzID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteLastProduct.t.Errorf("ReceptionServiceMock.DeleteLastProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteLastProduct.t.Fatal("No results are set for the ReceptionServiceMock.DeleteLastProduct")
		}
		return (*mm_results).err
	}
	if mmDeleteLastProduct.funcDeleteLastProduct != nil {
		return mmDeleteLastProduct.funcDeleteLastProduct(ctx, pvzID)
	}
	mmDeleteLastProduct.t.Fatalf("Unexpected call to ReceptionServiceMock.DeleteLastProduct. %v %v", ctx, pvzID)
	return
}

// DeleteLastProductAfterCounter returns a count of finished ReceptionServiceMock.DeleteLastProduct invocations
func (mmDeleteLastProduct *ReceptionServiceMock) DeleteLastProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteLastProduct.afterDeleteLastProductCounter)
}

// DeleteLastProductBeforeCounter returns a count of ReceptionServiceMock.DeleteLastProduct invocations
func (mmDeleteLastProduct *ReceptionServiceMock) DeleteLastProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteLastProduct.beforeDeleteLastProductCounter)
}

// Calls returns a list of arguments used in each call to ReceptionServiceMock.DeleteLastProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteLastProduct *mReceptionServiceMockDeleteLastProduct) Calls() []*ReceptionServiceMockDeleteLastProductParams {
	mmDeleteLastProduct.mutex.RLock()

	argCopy := make([]*ReceptionServiceMockDeleteLastProductParams, len(mmDeleteLastProduct.callArgs))
	copy(argCopy, mmDeleteLastProduct.callArgs)

	mmDeleteLastProduct.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteLastProductDone returns true if the count of the DeleteLastProduct invocations corresponds
// the number of defined expectations
func (m *ReceptionServiceMock) MinimockDeleteLastProductDone() bool {
	if m.DeleteLastProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteLastProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteLastProductMock.invocationsDone()
}

// MinimockDeleteLastProductInspect logs each unmet expectation
func (m *ReceptionServiceMock) MinimockDeleteLastProductInspect() {
	for _, e := range m.DeleteLastProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionServiceMock.DeleteLastProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteLastProductCounter := mm_atomic.LoadUint64(&m.afterDeleteLastProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteLastProductMock.defaultExpectation != nil && afterDeleteLastProductCounter < 1 {
		if m.DeleteLastProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionServiceMock.DeleteLastProduct at\n%s", m.DeleteLastProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionServiceMock.DeleteLastProduct at\n%s with params: %#v", m.DeleteLastProductMock.defaultExpectation.expectationOrigins.origin, *m.DeleteLastProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteLastProduct != nil && afterDeleteLastProductCounter < 1 {
		m.t.Errorf("Expected call to ReceptionServiceMock.DeleteLastProduct at\n%s", m.funcDeleteLastProductOrigin)
	}

	if !m.DeleteLastProductMock.invocationsDone() && afterDeleteLastProductCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionServiceMock.DeleteLastProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteLastProductMock.expectedInvocations), m.DeleteLastProductMock.expectedInvocationsOrigin, afterDeleteLastProductCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReceptionServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddProductInspect()

			m.MinimockCloseLastReceptionInspect()

			m.MinimockCreateReceptionInspect()

			m.MinimockDeleteLastProductInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReceptionServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReceptionServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddProductDone() &&
		m.MinimockCloseLastReceptionDone() &&
		m.MinimockCreateReceptionDone() &&
		m.MinimockDeleteLastProductDone()
}
